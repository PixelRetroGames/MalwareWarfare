#include "map_editor.h"

void Map_Editor::Clear()
{
 map.Clear();
 cpu.Clear();
 Destroy_Texture(tiles_highlighter);
}

void Map_Editor::Set_filename(char *_filename)
{
 strcpy(filename,_filename);
}

void Map_Editor::Load()
{
 Load_level_images();
 map.Load(filename);
 map.Set_same_color();
 cpu.Load();
 Texture *tile_highlight=Load_Transparent_Texture("res/images/tile_highlight.png");
 tiles_highlighter=Create_Transparent_Texture(map.Get_size()*tile_highlight->w,map.Get_size()*tile_highlight->h);
 for(int i=0;i<map.Get_size();i++)
     for(int j=0;j<map.Get_size();j++)
         {
          Apply_Texture(i*tile_highlight->w,j*tile_highlight->h,tile_highlight,tiles_highlighter);
         }
 Destroy_Texture(tile_highlight);
}

void Map_Editor::Save()
{
 map.Save(filename);
 Clear();
}

void Map_Editor::Print(Texture *_screen)
{
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 buffer=Create_Transparent_Texture(tiles_highlighter->w,tiles_highlighter->h);
 map.Print(buffer,0,0);
 Apply_Texture(0,0,tiles_highlighter,buffer);
 //Flip_Buffers(_screen);
 Apply_Texture({0,0,tiles_highlighter->w,tiles_highlighter->h},buffer,
               {MENU_OPTION_BACKGROUND->w,0,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT},_screen);
 cpu.Set_health(CPU_HEALTH);
 cpu.Set_screen_pos(CPU_POSITION.x,CPU_POSITION.y);
 cpu.Set_map_pos(FLOW_START_POS.x,FLOW_START_POS.y);
 cpu.Print(MENU_OPTION_BACKGROUND->w,0,_screen);
 Destroy_Texture(buffer);
}

void Map_Editor::Handle_Events(SDL_Event *event)
{
 std::pair<int,int> cursor_pos_on_screen;
 std::pair<int,int> cursor_pos={-1,-1};
 cursor_pos_on_screen.first=(event->button.x/RATIO_W-MENU_OPTION_BACKGROUND->w)*ARENA_RATIO;
 cursor_pos_on_screen.second=(event->button.y/RATIO_H)*ARENA_RATIO;
 if((cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT>=0 && (cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT<ARENA_SIZE &&
    (cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT>=0 && (cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT<ARENA_SIZE)
     {
      cursor_pos.second=(cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT;
      cursor_pos.first=(cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT;
     }
 if(event->type==SDL_MOUSEBUTTONDOWN)
    {
     pressed=true;
     last_button_draw=(event->button.button==SDL_BUTTON_LEFT);
     last_button_erase=(event->button.button==SDL_BUTTON_RIGHT);
    }
 if(event->type==SDL_MOUSEBUTTONUP)
    {
     pressed=false;
    }
 if(pressed && cursor_pos.first!=-1)
    {
     if(last_button_draw)
        map.Set_tile(cursor_pos.first,cursor_pos.second,true),updated=true;
     if(last_button_erase)
        map.Set_tile(cursor_pos.first,cursor_pos.second,false),updated=true;
    }
 if(updated)
    map.Configure();
}

const int MAX_SIZE=24,MIN_SIZE=10;
const int EVENT_DELAY=200;

void Map_Editor::Size_screen(Texture *_screen)
{
 bool quit=false;
 SDL_Event event;
 int size=(MAX_SIZE+MIN_SIZE)/2;
 size+=size%2;
 Timer event_timer;
 event_timer.start();
 while(!quit)
       {
        SDL_PollEvent(&event);
        if(event.type==SDL_MOUSEBUTTONDOWN && event_timer.get_ticks()>EVENT_DELAY)
           {
            if(event.button.button==SDL_BUTTON_LEFT)
               {
                size+=2;
                size=std::min(MAX_SIZE,size);
                event_timer.start();
               }
            if(event.button.button==SDL_BUTTON_RIGHT)
               {
                size-=2;
                size=std::max(MIN_SIZE,size);
                event_timer.start();
               }
           }
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE] || keystates[SDL_SCANCODE_RETURN];
        quit=(quit || event.type==SDL_QUIT);
        Texture *size_texture;
        char aux[TEXT_LENGTH_MAX]={NULL},aux1[TEXT_LENGTH_MAX]={NULL};
        itoa(size,aux);
        strcpy(aux1,"Map size = ");
        strcat(aux1,aux);
        size_texture=Create_TTF_Texture(MENU_FONT_BIG,aux1,{255,255,255});
        Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
        Apply_Texture((_screen->w-size_texture->w)/2,(_screen->h-size_texture->h)/2,size_texture,_screen);
        Flip_Buffers(_screen);
       }
 New_map(size);
}

void Map_Editor::New_map(int size)
{
 FLOW_START_POS={size/2-1,size/2-1,0,0};
 FILE *out=fopen(filename,"w");
 fprintf(out,"%d\n\n",size);
 for(int i=0;i<size;i++)
     {
      for(int j=0;j<size;j++)
          {
           if((i==FLOW_START_POS.x && j==FLOW_START_POS.y) ||
              (i==FLOW_START_POS.x+1 && j==FLOW_START_POS.y) ||
              (i==FLOW_START_POS.x+1 && j==FLOW_START_POS.y+1) ||
              (i==FLOW_START_POS.x && j==FLOW_START_POS.y+1))
              fprintf(out,"1 ");
           else
              fprintf(out,"0 ");
          }
      fprintf(out,"\n");
     }
 fclose(out);
}

void Map_Editor::Start(bool is_new,Texture *_screen)
{
 if(is_new)
    {
     Size_screen(_screen);
     Load();
    }
 bool quit=false;
 SDL_Event event;
 while(!quit)
       {
        SDL_PollEvent(&event);
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        quit=(quit || event.type==SDL_QUIT);
        Handle_Events(&event);
        Print(_screen);
        Flip_Buffers(_screen);
       }
 Clear_level_images();
}

