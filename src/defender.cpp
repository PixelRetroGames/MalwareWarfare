#include "defender.h"

const int NUMBER_OF_FIREWALL_TYPES=4;
const char *FIREWALL_TYPES[]={"slow_tower","antivirus scanner","firewall plus","security service","healer"};

int Defender::Get_type(char *type)
{
 for(int i=0;i<NUMBER_OF_FIREWALL_TYPES;i++)
     if(strcmp(type,FIREWALL_TYPES[i])==0)
        return i;
 SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR,"Invalid firewall type",type,NULL);
 exit(-1);
}

char PATH_TO_ALL_FIREWALLS[]={"res/firewall/all.mwafw"};

void Defender::Load(int _id)
{
 Set_id(_id);
 FILE *in=fopen(PATH_TO_ALL_FIREWALLS,"r");
 for(int i=0;i<4;i++)
     {
      char path[TEXT_LENGTH_MAX];
      fgets(path,sizeof path,in);
      int sq=strlen(path);
      if(path[sq-1]=='\n')
         path[sq-1]=NULL;

      char type[TEXT_LENGTH_MAX];
      fgets(type,sizeof type,in);
      sq=strlen(type);
      if(type[sq-1]=='\n')
         type[sq-1]=NULL;

      Firewall *aux;
      switch(Get_type(type))
             {
              case 0: aux=new Slow_Tower;
                      break;
              case 1: aux=new Antivirus_scanner;
                      break;
              case 2: aux=new Firewall_plus;
                      break;
              case 3: aux=new Security_service;
                      break;
              case 4: aux=new Healer;
                      break;
             };
      aux->Load(path,i);
      unit.push_back(aux);
     }
 fclose(in);
 char aux[TEXT_LENGTH_MAX];
 strcpy(aux,"P");
 strcat(aux,_id==1?"1":"2");
 strcat(aux," - defender");
 player_image=Create_TTF_Texture(MENU_FONT_BIG,aux,DEFENDER_ID_COLOR);
 event_timer.start();
 unit_cursor_pos=0;
 Set_ram(INITIAL_RAM_DEFENDER);
}

void Defender::Clear_available_positions()
{
 for(int q=0;q<FIREWALL_TYPES_CONFIGS;q++)
     {
      for(int i=0;i<arena_size;i++)
          for(int j=0;j<arena_size;j++)
              available_cursor_positions[q][i][j]=false;
     }
}

Defender::Defender(int _arena_size)
{
 arena_size=_arena_size;
 for(int q=0;q<FIREWALL_TYPES_CONFIGS;q++)
     {
      available_cursor_positions[q]=new int*[arena_size];
      for(int i=0;i<arena_size;i++)
          available_cursor_positions[q][i]=new int[arena_size];
     }
 Clear_available_positions();
}

Defender::~Defender()
{
 for(int q=0;q<FIREWALL_TYPES_CONFIGS;q++)
     {
      for(int i=0;i<arena_size;i++)
          delete[] available_cursor_positions[q][i];
      delete[] available_cursor_positions[q];
     }
}

void Defender::Reset()
{
 unit_cursor_pos=0;
 Set_ram(0);
}

void Defender::Clear()
{
 Player::Clear();
 unit_cursor_pos=0;
 Clear_available_positions();
}

Firewall *Defender::Get_firewall(int _id)
{
 return Get_unit(_id);
}

std::pair<int,int> Defender::Get_cursor_position()
{
 return cursor_pos;
}

void Defender::Set_available_cursor_position(int type,std::pair<int,int> _pos,int _val)
{
 if(_val==2)
    {
     for(int i=0;i<FIREWALL_TYPES_CONFIGS;i++)
         if(available_cursor_positions[i][_pos.first][_pos.second]==1)
            available_cursor_positions[i][_pos.first][_pos.second]=_val;
    }
 if(_val==1)
    {
     for(int i=0;i<FIREWALL_TYPES_CONFIGS;i++)
         if(available_cursor_positions[i][_pos.first][_pos.second]==2)
            available_cursor_positions[i][_pos.first][_pos.second]=_val;
    }
 available_cursor_positions[type][_pos.first][_pos.second]=_val;
}

bool Defender::Can_cast(int _id)
{
 return (unit[_id]->Is_cool() && unit[_id]->Is_enough_ram(ram));
}

int Defender::Handle_Events(int x,int y,SDL_Event *event)
{
 if(event->type==SDL_MOUSEMOTION)
    {
     cursor_pos_on_screen.first=(event->button.x/RATIO_W-x)*ARENA_RATIO;
     cursor_pos_on_screen.second=(event->button.y/RATIO_H-y)*ARENA_RATIO;
     if((cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT>=0 && (cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT<arena_size &&
        (cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT>=0 && (cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT<arena_size &&
        available_cursor_positions[Get_current_firewall_type()][(cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT][(cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT]==1)
        {
         cursor_pos.second=(cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT;
         cursor_pos.first=(cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT;
        }
     else
        {
         cursor_pos={-1,-1};
        }
    }
 else
    {
     if(cursor_pos.first==-1 || !available_cursor_positions[Get_current_firewall_type()][cursor_pos.first][cursor_pos.second]==1)
        {
         cursor_pos={-1,-1};
        }
     else
        {
         cursor_pos.second=(cursor_pos_on_screen.first)/PIXELS_PER_INGAME_UNIT;
         cursor_pos.first=(cursor_pos_on_screen.second)/PIXELS_PER_INGAME_UNIT;
        }
    }
 if(CONTROLLER_SCHEME==CONTROLLER_SCHEME_CONTROLLERS)
    {
     int ret=Player::Handle_Events();
     if(ret!=-1)
        {
         if(available_cursor_positions[Get_current_firewall_type()][cursor_pos.first][cursor_pos.second]==1)
            {
             //Set_used_ram(used_ram+unit[ret]->Get_ram_cost());
             available_cursor_positions[Get_current_firewall_type()][cursor_pos.first][cursor_pos.second]=2;
            }
         else
            return -1;
        }
     return ret;
    }
 else
    {
     if(event->type==SDL_MOUSEWHEEL)
        {
         cursor_pos={-1,-1};
         if(event->wheel.y>0) //scroll up
            {
             unit_cursor_pos--;
             if(unit_cursor_pos<0)
                unit_cursor_pos=NUMBER_OF_UNITS-1;
            }
         if(event->wheel.y<0) //scroll down
            {
             unit_cursor_pos++;
             unit_cursor_pos%=NUMBER_OF_UNITS;
            }
        }
     if(event->type==SDL_MOUSEBUTTONUP)
        {
         if(event_timer.get_ticks()>=EVENT_DELAY && cursor_pos!=std::make_pair(-1,-1) && Can_cast(unit_cursor_pos))
            {
             unit[unit_cursor_pos]->Start_cooldown();
             available_cursor_positions[Get_current_firewall_type()][cursor_pos.first][cursor_pos.second]=2;
             return unit_cursor_pos;
            }
        }
    }
 return -1;
}

void Defender::Print_info(int x,int y,Texture *_screen)
{
 Apply_Texture(x,y,MENU_BACKGROUND_DEFENDER,_screen);
 for(int i=0;i<NUMBER_OF_UNITS_ON_PAGE;i++)
     unit[3-i]->Print_in_menu(x,_screen->h-(i+1)*MENU_OPTION_BACKGROUND->h,_screen,ram);
 Apply_Texture(x+(MENU_OPTION_BACKGROUND->w-player_image->w)/2,y+(_screen->h-NUMBER_OF_UNITS_ON_PAGE*MENU_OPTION_BACKGROUND->h-player_image->h-ram_image->h)/2,player_image,_screen);
 Print_ram(x+(MENU_OPTION_BACKGROUND->w-ram_image->w)/2,y+(_screen->h-NUMBER_OF_UNITS_ON_PAGE*MENU_OPTION_BACKGROUND->h-player_image->h-ram_image->h)/2+player_image->h,_screen);
 Texture *temp;
 char aux[TEXT_LENGTH_MAX]={NULL},aux1[TEXT_LENGTH_MAX]={NULL};
 itoa(cursor_pos.first,aux1);
 strcat(aux,aux1);
 strcat(aux,", ");
 itoa(cursor_pos.second,aux1);
 strcat(aux,aux1);
 temp=Create_TTF_Texture(MENU_FONT_SMALL,aux,{255,255,255});
 Apply_Texture(_screen->w-temp->w,0,temp,_screen);
 Destroy_Texture(temp);

 itoa(cursor_pos_on_screen.first,aux1);
 memset(aux,0,sizeof aux);
 strcat(aux,aux1);
 strcat(aux,", ");
 itoa(cursor_pos_on_screen.second,aux1);
 strcat(aux,aux1);
 temp=Create_TTF_Texture(MENU_FONT_SMALL,aux,{255,255,255});
 Apply_Texture(_screen->w-temp->w,20,temp,_screen);
 Destroy_Texture(temp);

 Apply_Texture(x,_screen->h-(NUMBER_OF_UNITS-unit_cursor_pos)*MENU_OPTION_BACKGROUND->h,DEFENDER_UNIT_SELECTOR,_screen);
}

int Defender::Get_current_firewall_type()
{
 return Get_firewall_type(unit[unit_cursor_pos]);
}

void Defender::Print_available_pos()
{
 FILE *sq=fopen("sq.txt","w");
 for(int i=0;i<arena_size;i++)
     {
      for(int j=0;j<arena_size;j++)
          {
           fprintf(sq,"%d ",available_cursor_positions[i][j]?1:0);
          }
      fprintf(sq,"\n");
     }
 fclose(sq);
}

void Defender::Highlight_available_pos(int x,int y,Texture *_screen)
{
 for(int i=0;i<arena_size;i++)
     for(int j=0;j<arena_size;j++)
         if(available_cursor_positions[Get_current_firewall_type()][i][j]==1)
            Apply_Texture(x+j*PIXELS_PER_INGAME_UNIT,y+i*PIXELS_PER_INGAME_UNIT,DEFENDER_AVAILABLE_TILE,_screen);
}

int Get_firewall_type(Combat_unit *fw)
{
 if(typeid(*fw)==typeid(Trap) || typeid(*fw)==typeid(Security_service))
    return 1;
 if(typeid(*fw)==typeid(Antivirus_scanner))
    return 2;
 return 0;
}
