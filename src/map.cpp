#include "map.h"
#include <vector>
#include <queue>

const SDL_Rect FLOW_START_POS={4,4,0,0};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

Map::Map()
{
 for(int i=0;i<4;i++)
     tiles[i]=NULL;
 arena_tiles_frame=0;
}

void Map::Clear()
{
 for(int i=0;i<4;i++)
     {
      if(tiles[i]==NULL)
         continue;
      Destroy_Texture(tiles[i]);
      tiles[i]=NULL;
     }
 arena_tiles_frame=0;
}

void Map::Load(char *filename)
{
 FILE *in=fopen(filename,"r");
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         fscanf(in,"%d ",&arena[i][j]);
 fclose(in);

 Load_new_tile(0);
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         {
          arena_flow_direction[i][j]=-1;
          if(!arena[i][j])
             {
              arena_tiles[i][j]=0;
              continue;
             }
          bool neighbors[4]={0,0,0,0};
          char sum=0;
          for(int q=0;q<4;q++)
              {
               if(i+dirx[q]>=0 && i+dirx[q]<ARENA_SIZE && j+diry[q]>=0 && j+diry[q]<ARENA_SIZE)
                  neighbors[q]=arena[i+dirx[q]][j+diry[q]],sum+=arena[i+dirx[q]][j+diry[q]];
              }
          arena_tiles[i][j]=Get_tile_from_neighbors(neighbors,&arena_tiles_angles[i][j]);
          if(tiles[arena_tiles[i][j]]==NULL)
             Load_new_tile(arena_tiles[i][j]);
         }
 Create_flow();
}

int Map::Get_tile_from_neighbors(bool *neighbors,int *angle)
{
 std::vector<int> aux;
 for(int i=0;i<4;i++)
     if(neighbors[i])
        aux.push_back(i);
 if(aux.size()==0 || aux.size()==4)
    {
     *angle=0;
     return 0;
    }
 if(aux.size()==1)
    {
     *angle=aux[0]*90;
     return 1;
    }
 if(aux.size()==2)
    {
     if(aux[1]-aux[0]==1 || aux[1]-aux[0]==3)
        {
         *angle=aux[1]-aux[0]==3?270:aux[0]*90;
         return 2;
        }
     if(aux[1]-aux[0]==2)
        {
         *angle=aux[0]*90;
         return 1;
        }
    }
 if(aux.size()==3)
    {
     *angle=aux[2]-aux[0]==2?aux[0]*90+90:(2-aux[1])*90+270;
     return 3;
    }
}

void Map::Load_new_tile(int _id)
{
 char aux[TEXT_LENGTH_MAX],aux1[TEXT_LENGTH_MAX];
 strcpy(aux,"res/tiles/");
 itoa(_id,aux1);
 strcat(aux,aux1);
 strcat(aux,".png");
 Texture *_aux=Load_Transparent_Texture(aux);
 tiles[_id]=Create_Transparent_Texture((PIXELS_PER_INGAME_UNIT+1),PIXELS_PER_INGAME_UNIT+1);
 Apply_Texture(0,0,_aux,tiles[_id]);
 Destroy_Texture(_aux);
}

void Map::Create_flow()
{
 std::queue<std::pair<int,int>> que;
 arena_flow_direction[FLOW_START_POS.x][FLOW_START_POS.y]=0;
 que.push({FLOW_START_POS.x,FLOW_START_POS.y});
 while(!que.empty())
       {
        int x,y;
        x=que.front().first;
        y=que.front().second;
        que.pop();
        for(int i=0;i<4;i++)
            {
             if(x+dirx[i]>=0 && x+dirx[i]<ARENA_SIZE && y+diry[i]>=0 && y+diry[i]<ARENA_SIZE && arena[x+dirx[i]][y+diry[i]] &&
                arena_flow_direction[x+dirx[i]][y+diry[i]]==-1)
                {
                 arena_flow_direction[x+dirx[i]][y+diry[i]]=dir_reversed[i];
                 que.push({x+dirx[i],y+diry[i]});
                }
            }
       }
}

void Map::Print_tile(Texture *_screen,int x,int y,int i,int j)
{
 if(arena_tiles[i][j]==0)
    return;
 Apply_Rotated_Texture(tiles[arena_tiles[i][j]],{arena_tiles_frame*(PIXELS_PER_INGAME_UNIT+1),0,PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                       _screen,{x+j*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                       (double)1.00*arena_tiles_angles[i][j]);
 if(i==0 || j==0 || i==ARENA_SIZE-1 || j==ARENA_SIZE-1)
    Apply_Rotated_Texture(tiles[0],{arena_tiles_frame*(PIXELS_PER_INGAME_UNIT+1),0,PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                          _screen,{x+j*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                          (double)1.00*arena_tiles_angles[i][j]);
}

void Map::Print(Texture *_screen,int x,int y)
{
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         Print_tile(_screen,x,y,i,j);
}

const int ARENA_TILES_FRAMES=1;

void Map::Update_frames()
{
 arena_tiles_frame++;
 arena_tiles_frame%=ARENA_TILES_FRAMES;
}

std::vector<std::pair<int,int> > Map::Get_open_ports()
{
 std::vector<std::pair<int,int> > ret;
 for(int i=0;i<ARENA_SIZE;i++)
     if(arena[0][i])
        ret.push_back({0,i});
 for(int i=0;i<ARENA_SIZE;i++)
     if(arena[i][ARENA_SIZE-1])
        ret.push_back({i,ARENA_SIZE-1});
 for(int i=ARENA_SIZE-1;i>=0;i--)
     if(arena[ARENA_SIZE-1][i])
        ret.push_back({ARENA_SIZE-1,i});
 for(int i=ARENA_SIZE-1;i>=0;i--)
     if(arena[i][0])
        ret.push_back({i,0});
 return ret;
}

int Map::Get_flow_direction(int x,int y)
{
 return arena_flow_direction[x][y];
}
