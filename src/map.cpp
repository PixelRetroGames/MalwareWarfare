#include "map.h"
#include <vector>
#include <queue>

const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

Map::Map()
{
 for(int c=0;c<NUMBER_OF_TILES_COLORS;c++)
     for(int i=0;i<5;i++)
         tiles[c][i]=NULL;
 arena_tiles_frame=0;
}

void Map::Clear()
{
 for(int i=0;i<size;i++)
     {
      delete[] arena[i];
      delete[] arena_tiles_colors[i];
      delete[] arena_tiles[i];
      delete[] arena_tiles_angles[i];
      delete[] arena_flow_direction[i];
     }

 delete[] arena;
 delete[] arena_tiles_colors;
 delete[] arena_tiles;
 delete[] arena_tiles_angles;
 delete[] arena_flow_direction;

 for(int c=0;c<NUMBER_OF_TILES_COLORS;c++)
     {
      for(int i=0;i<5;i++)
          {
           if(tiles[c][i]==NULL)
              continue;
           Destroy_Texture(tiles[c][i]);
           tiles[c][i]=NULL;
          }
     }
 arena_tiles_frame=0;
}

void Map::Load(char *filename)
{
 FILE *in=fopen(filename,"r");
 fscanf(in,"%d ",&size);
 ARENA_SIZE=size;
 ARENA_RATIO=(1.000*ARENA_SIZE)/ARENA_DEFAULT_SIZE;
 FLOW_START_POS={ARENA_SIZE/2-1,ARENA_SIZE/2-1,0,0};

 arena=new bool*[size];
 arena_tiles_colors=new int*[size];
 arena_tiles=new int*[size];
 arena_tiles_angles=new int*[size];
 arena_flow_direction=new int*[size];
 for(int i=0;i<size;i++)
     {
      arena[i]=new bool[size];
      arena_tiles_colors[i]=new int[size];
      arena_tiles[i]=new int[size];
      arena_tiles_angles[i]=new int[size];
      arena_flow_direction[i]=new int[size];
     }

 for(int i=0;i<size;i++)
     for(int j=0;j<size;j++)
         {
          fscanf(in,"%d ",&arena[i][j]);
          arena_tiles_colors[i][j]=0;
          arena_tiles_angles[i][j]=0;
          arena_flow_direction[i][j]=0;
         }
 fclose(in);
 Configure();
 Create_flow();
 Color_lanes();
}

void Map::Configure()
{
 Load_new_tile(0);
 for(int i=0;i<size;i++)
     for(int j=0;j<size;j++)
         {
          arena_flow_direction[i][j]=-1;
          if(!arena[i][j])
             {
              arena_tiles[i][j]=0;
              continue;
             }
          bool neighbors[4]={0,0,0,0};
          char sum=0;
          for(int q=0;q<4;q++)
              {
               if(i+dirx[q]>=0 && i+dirx[q]<size && j+diry[q]>=0 && j+diry[q]<size)
                  neighbors[q]=arena[i+dirx[q]][j+diry[q]],sum+=arena[i+dirx[q]][j+diry[q]];
              }
          arena_tiles[i][j]=Get_tile_from_neighbors(neighbors,&arena_tiles_angles[i][j]);
          if(tiles[0][arena_tiles[i][j]]==NULL)
             Load_new_tile(arena_tiles[i][j]);
         }
}

int Map::Get_tile_from_neighbors(bool *neighbors,int *angle)
{
 std::vector<int> aux;
 for(int i=0;i<4;i++)
     if(neighbors[i])
        aux.push_back(i);
 if(aux.size()==0 || aux.size()==4)
    {
     *angle=0;
     return aux.size()==0?0:4;
    }
 if(aux.size()==1)
    {
     *angle=aux[0]*90;
     return 1;
    }
 if(aux.size()==2)
    {
     if(aux[1]-aux[0]==1 || aux[1]-aux[0]==3)
        {
         *angle=aux[1]-aux[0]==3?270:aux[0]*90;
         return 2;
        }
     if(aux[1]-aux[0]==2)
        {
         *angle=aux[0]*90;
         return 1;
        }
    }
 if(aux.size()==3)
    {
     *angle=aux[2]-aux[0]==2?aux[0]*90+90:(2-aux[1])*90+270;
     return 3;
    }
}

void Map::Load_new_tile(int _id)
{
 for(int i=0;i<NUMBER_OF_TILES_COLORS;i++)
     {
      char aux[TEXT_LENGTH_MAX],aux1[TEXT_LENGTH_MAX];
      strcpy(aux,"res/tiles/");
      itoa(i,aux1);
      strcat(aux,aux1);
      strcat(aux,"/");
      itoa(_id,aux1);
      strcat(aux,aux1);
      strcat(aux,".png");
      Texture *_aux=Load_Transparent_Texture(aux);
      tiles[i][_id]=Create_Transparent_Texture((PIXELS_PER_INGAME_UNIT+1),PIXELS_PER_INGAME_UNIT+1);
      Apply_Texture(0,0,_aux,tiles[i][_id]);
      Destroy_Texture(_aux);
     }
}

void Map::Create_flow()
{
 std::queue<std::pair<int,int>> que;
 arena_flow_direction[FLOW_START_POS.x][FLOW_START_POS.y]=-1;
 que.push({FLOW_START_POS.x,FLOW_START_POS.y});
 while(!que.empty())
       {
        int x,y;
        x=que.front().first;
        y=que.front().second;
        que.pop();
        for(int i=0;i<4;i++)
            {
             if(x+dirx[i]>=0 && x+dirx[i]<size && y+diry[i]>=0 && y+diry[i]<size && arena[x+dirx[i]][y+diry[i]] &&
                arena_flow_direction[x+dirx[i]][y+diry[i]]==-1)
                {
                 arena_flow_direction[x+dirx[i]][y+diry[i]]=dir_reversed[i];
                 que.push({x+dirx[i],y+diry[i]});
                }
            }
       }
}

void Map::Print_tile(Texture *_screen,int x,int y,int i,int j)
{
 if(arena_tiles[i][j]==0 || arena_tiles_colors[i][j]<=0)
    return;
 Apply_Rotated_Texture(tiles[arena_tiles_colors[i][j]-1][arena_tiles[i][j]],{arena_tiles_frame*(PIXELS_PER_INGAME_UNIT+1),0,PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                       _screen,{x+j*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                       (double)1.00*arena_tiles_angles[i][j]);
 if(i==0 || j==0 || i==size-1 || j==size-1)
    Apply_Rotated_Texture(tiles[arena_tiles_colors[i][j]-1][0],{arena_tiles_frame*(PIXELS_PER_INGAME_UNIT+1),0,PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                          _screen,{x+j*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*PIXELS_PER_INGAME_UNIT-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),PIXELS_PER_INGAME_UNIT+1,PIXELS_PER_INGAME_UNIT+1},
                          (double)1.00*arena_tiles_angles[i][j]);
 /*if(arena_tiles_colors[i][j]>0)
    Apply_Texture(x+j*PIXELS_PER_INGAME_UNIT,y+i*PIXELS_PER_INGAME_UNIT,ARENA_COLORS[arena_tiles_colors[i][j]-1],_screen);*/
}

void Map::Print(Texture *_screen,int x,int y)
{
 for(int i=0;i<size;i++)
     for(int j=0;j<size;j++)
         Print_tile(_screen,x,y,i,j);
}

const int ARENA_TILES_FRAMES=1;

void Map::Update_frames()
{
 arena_tiles_frame++;
 arena_tiles_frame%=ARENA_TILES_FRAMES;
}

std::vector<std::pair<int,int> > Map::Get_open_ports()
{
 std::vector<std::pair<int,int> > ret;
 for(int i=0;i<size;i++)
     if(arena[0][i])
        ret.push_back({0,i});
 for(int i=0;i<size;i++)
     if(arena[i][size-1])
        ret.push_back({i,size-1});
 for(int i=size-1;i>=0;i--)
     if(arena[size-1][i])
        ret.push_back({size-1,i});
 for(int i=size-1;i>=0;i--)
     if(arena[i][0])
        ret.push_back({i,0});
 return ret;
}

int Map::Get_flow_direction(int x,int y)
{
 return arena_flow_direction[x][y];
}

int Map::Get_flow_direction(std::pair<int,int> pos)
{
 return Get_flow_direction(pos.first,pos.second);
}

bool Map::Is_obstacle(int x,int y)
{
 if(x<0 || x>=size || y<0 || y>=size)
    return true;
 return !arena[x][y];
}

const int CPU_SIZE=2;

void Map::Color_lanes()
{
 for(int i=0;i<size;i++)
     for(int j=0;j<size;j++)
         arena_tiles_colors[i][j]=0;
 for(int i=0;i<CPU_SIZE;i++)
     for(int j=0;j<CPU_SIZE;j++)
         arena_tiles_colors[FLOW_START_POS.x+i][FLOW_START_POS.y+j]=-1;

 int current_color=0;
 for(int i=0;i<CPU_SIZE;i++)
     for(int j=0;j<CPU_SIZE;j++)
         for(int d=0;d<4;d++)
             {
              int x1=FLOW_START_POS.x+i+dirx[d];
              int y1=FLOW_START_POS.y+j+diry[d];
              if(x1>=0 && x1<size && y1>=0 && y1<size && arena[x1][y1] && arena_tiles_colors[x1][y1]==0)
                {
                 current_color++;
                 Color_lane(x1,y1,current_color);
                 arena_tiles_colors[FLOW_START_POS.x+i][FLOW_START_POS.y+j]=current_color;
                }
             }
}

void Map::Color_lane(int x,int y,int color)
{
 std::queue<std::pair<int,int> > que;
 que.push({x,y});
 arena_tiles_colors[x][y]=color;
 while(!que.empty())
       {
        std::pair<int,int> elem=que.front();
        que.pop();
        for(int d=0;d<4;d++)
            {
             int x1=elem.first+dirx[d],y1=elem.second+diry[d];
             if(x1>=0 && x1<size && y1>=0 && y1<size && arena[x1][y1] && arena_tiles_colors[x1][y1]==0)
                {
                 que.push({x1,y1});
                 arena_tiles_colors[x1][y1]=color;
                }
            }
       }
}

int Map::Get_size()
{
 return size;
}

void Map::Set_size(int _size)
{
 size=_size;
}

void Map::Save(char *filename)
{
 FILE *out=fopen(filename,"w");
 fprintf(out,"%d\n\n",size);
 for(int i=0;i<size;i++)
     {
      for(int j=0;j<size;j++)
          {
           fprintf(out,"%d ",arena[i][j]);
          }
      fprintf(out,"\n");
     }
 fclose(out);
}

void Map::Set_tile(int x,int y,bool val)
{
 if(x==0 && y==0 && val==true)
    printf("t");
 arena[x][y]=val;
}

void Map::Set_same_color()
{
 for(int i=0;i<size;i++)
     for(int j=0;j<size;j++)
         arena_tiles_colors[i][j]=1;
}
