#include "map.h"
#include <vector>
#include <queue>

const SDL_Rect FLOW_START_POS={11,11,0,0};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

Map::Map()
{
 for(int c=0;c<NUMBER_OF_TILES_COLORS;c++)
     for(int i=0;i<5;i++)
         tiles[c][i]=NULL;
 arena_tiles_frame=0;
}

void Map::Clear()
{
 for(int c=0;c<NUMBER_OF_TILES_COLORS;c++)
     {
      for(int i=0;i<5;i++)
          {
           if(tiles[c][i]==NULL)
              continue;
           Destroy_Texture(tiles[c][i]);
           tiles[c][i]=NULL;
          }
     }
 arena_tiles_frame=0;
}

void Map::Load(char *filename)
{
 FILE *in=fopen(filename,"r");
 for(int i=0;i<ARENA_SIZE_LOGIC;i++)
     for(int j=0;j<ARENA_SIZE_LOGIC;j++)
         fscanf(in,"%d ",&arena[i][j]);
 fclose(in);

 Load_new_tile(0);
 for(int i=1;i<ARENA_SIZE_LOGIC;i+=2)
     for(int j=1;j<ARENA_SIZE_LOGIC;j+=2)
         {
          arena_flow_direction[i][j]=-1;
          if(!arena[i][j])
             {
              arena_tiles[i/2][j/2]=0;
              continue;
             }
          bool neighbors[4]={0,0,0,0};
          char sum=0;
          for(int q=0;q<4;q++)
              {
               if(i+dirx[q]>=0 && i+dirx[q]<ARENA_SIZE_LOGIC && j+diry[q]>=0 && j+diry[q]<ARENA_SIZE_LOGIC)
                  neighbors[q]=arena[i+dirx[q]][j+diry[q]],sum+=arena[i+dirx[q]][j+diry[q]];
              }
          arena_tiles[i/2][j/2]=Get_tile_from_neighbors(neighbors,&arena_tiles_angles[i/2][j/2]);
          if(tiles[0][arena_tiles[i/2][j/2]]==NULL)
             Load_new_tile(arena_tiles[i/2][j/2]);
         }
 FILE *out=fopen("sq.out","w");
 for(int i=0;i<ARENA_SIZE_GRAPHIC;i++)
     {
      for(int j=0;j<ARENA_SIZE_GRAPHIC;j++)
          fprintf(out,"%d ",arena_tiles[i][j]);
      fprintf(out,"\n");
     }
 fclose(out);
 Create_flow();
 Color_lanes();
 out=fopen("colors.out","w");
 for(int i=0;i<ARENA_SIZE_GRAPHIC;i++)
     {
      for(int j=0;j<ARENA_SIZE_GRAPHIC;j++)
          fprintf(out,"%d ",arena_tiles_colors[i][j]);
      fprintf(out,"\n");
     }
 fclose(out);
}

int Map::Get_tile_from_neighbors(bool *neighbors,int *angle)
{
 std::vector<int> aux;
 for(int i=0;i<4;i++)
     if(neighbors[i])
        aux.push_back(i);
 if(aux.size()==0 || aux.size()==4)
    {
     *angle=0;
     return aux.size()==0?0:4;
    }
 if(aux.size()==1)
    {
     *angle=aux[0]*90;
     return 1;
    }
 if(aux.size()==2)
    {
     if(aux[1]-aux[0]==1 || aux[1]-aux[0]==3)
        {
         *angle=aux[1]-aux[0]==3?270:aux[0]*90;
         return 2;
        }
     if(aux[1]-aux[0]==2)
        {
         *angle=aux[0]*90;
         return 1;
        }
    }
 if(aux.size()==3)
    {
     *angle=aux[2]-aux[0]==2?aux[0]*90+90:(2-aux[1])*90+270;
     return 3;
    }
}

void Map::Load_new_tile(int _id)
{
 for(int i=0;i<NUMBER_OF_TILES_COLORS;i++)
     {
      char aux[TEXT_LENGTH_MAX],aux1[TEXT_LENGTH_MAX];
      strcpy(aux,"res/tiles/");
      itoa(i,aux1);
      strcat(aux,aux1);
      strcat(aux,"/");
      itoa(_id,aux1);
      strcat(aux,aux1);
      strcat(aux,".png");
      Texture *_aux=Load_Transparent_Texture(aux);
      tiles[i][_id]=Create_Transparent_Texture((ARENA_TILE_SIZE_GRAPHIC+1),ARENA_TILE_SIZE_GRAPHIC+1);
      Apply_Texture(0,0,_aux,tiles[i][_id]);
      Destroy_Texture(_aux);
     }
}

void Map::Create_flow()
{
 std::queue<std::pair<int,int>> que;
 arena_flow_direction[FLOW_START_POS.x][FLOW_START_POS.y]=-1;
 que.push({FLOW_START_POS.x,FLOW_START_POS.y});
 while(!que.empty())
       {
        int x,y;
        x=que.front().first;
        y=que.front().second;
        que.pop();
        for(int i=0;i<4;i++)
            {
             if(x+dirx[i]>=0 && x+dirx[i]<ARENA_SIZE_LOGIC && y+diry[i]>=0 && y+diry[i]<ARENA_SIZE_LOGIC && arena[x+dirx[i]][y+diry[i]] &&
                arena_flow_direction[x+dirx[i]][y+diry[i]]==-1)
                {
                 arena_flow_direction[x+dirx[i]][y+diry[i]]=dir_reversed[i];
                 que.push({x+dirx[i],y+diry[i]});
                }
            }
       }
}

void Map::Print_tile(Texture *_screen,int x,int y,int i,int j)
{
 if(arena_tiles[i][j]==0 || arena_tiles_colors[i][j]<=0)
    return;
 Apply_Rotated_Texture(tiles[arena_tiles_colors[i][j]-1][arena_tiles[i][j]],{arena_tiles_frame*(ARENA_TILE_SIZE_GRAPHIC+1),0,ARENA_TILE_SIZE_GRAPHIC+1,ARENA_TILE_SIZE_GRAPHIC+1},
                       _screen,{x+j*ARENA_TILE_SIZE_GRAPHIC-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*ARENA_TILE_SIZE_GRAPHIC-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),ARENA_TILE_SIZE_GRAPHIC+1,ARENA_TILE_SIZE_GRAPHIC+1},
                       (double)1.00*arena_tiles_angles[i][j]);
 if(i==0 || j==0 || i==ARENA_SIZE_GRAPHIC-1 || j==ARENA_SIZE_GRAPHIC-1)
    Apply_Rotated_Texture(tiles[arena_tiles_colors[i][j]-1][0],{arena_tiles_frame*(ARENA_TILE_SIZE_GRAPHIC+1),0,ARENA_TILE_SIZE_GRAPHIC+1,ARENA_TILE_SIZE_GRAPHIC+1},
                          _screen,{x+j*ARENA_TILE_SIZE_GRAPHIC-(arena_tiles_angles[i][j]==180 || arena_tiles_angles[i][j]==90),y+i*ARENA_TILE_SIZE_GRAPHIC-(arena_tiles_angles[i][j]==270 || arena_tiles_angles[i][j]==180),ARENA_TILE_SIZE_GRAPHIC+1,ARENA_TILE_SIZE_GRAPHIC+1},
                          (double)1.00*arena_tiles_angles[i][j]);
 /*if(arena_tiles_colors[i][j]>0)
    Apply_Texture(x+j*ARENA_TILE_SIZE_GRAPHIC,y+i*ARENA_TILE_SIZE_GRAPHIC,ARENA_COLORS[arena_tiles_colors[i][j]-1],_screen);*/
}

void Map::Print(Texture *_screen,int x,int y)
{
 for(int i=0;i<ARENA_SIZE_GRAPHIC;i++)
     for(int j=0;j<ARENA_SIZE_GRAPHIC;j++)
         Print_tile(_screen,x,y,i,j);
}

const int ARENA_TILES_FRAMES=1;

void Map::Update_frames()
{
 arena_tiles_frame++;
 arena_tiles_frame%=ARENA_TILES_FRAMES;
}

std::vector<std::pair<int,int> > Map::Get_open_ports()
{
 std::vector<std::pair<int,int> > ret;
 for(int i=0;i<ARENA_SIZE_LOGIC;i++)
     if(arena[0][i])
        ret.push_back({0,i});
 for(int i=0;i<ARENA_SIZE_LOGIC;i++)
     if(arena[i][ARENA_SIZE_LOGIC-1])
        ret.push_back({i,ARENA_SIZE_LOGIC-1});
 for(int i=ARENA_SIZE_LOGIC-1;i>=0;i--)
     if(arena[ARENA_SIZE_LOGIC-1][i])
        ret.push_back({ARENA_SIZE_LOGIC-1,i});
 for(int i=ARENA_SIZE_LOGIC-1;i>=0;i--)
     if(arena[i][0])
        ret.push_back({i,0});
 return ret;
}

int Map::Get_flow_direction(int x,int y)
{
 return arena_flow_direction[x][y];
}

int Map::Get_flow_direction(std::pair<int,int> pos)
{
 return Get_flow_direction(pos.first,pos.second);
}

bool Map::Is_obstacle(int x,int y)
{
 return !arena[x][y];
}

const int CPU_SIZE=4;

void Map::Color_lanes()
{
 memset(arena_tiles_colors,0,sizeof arena_tiles_colors);
 for(int i=0;i<CPU_SIZE/2;i++)
     for(int j=0;j<CPU_SIZE/2;j++)
         arena_tiles_colors[FLOW_START_POS.x/2+i][FLOW_START_POS.y/2+j]=-1;

 int current_color=0;
 for(int i=0;i<CPU_SIZE/2;i++)
     for(int j=0;j<CPU_SIZE/2;j++)
         for(int d=0;d<4;d++)
             {
              int x1=FLOW_START_POS.x/2+i+dirx[d];
              int y1=FLOW_START_POS.y/2+j+diry[d];
              if(x1>=0 && x1<ARENA_SIZE_GRAPHIC && y1>=0 && y1<ARENA_SIZE_GRAPHIC && arena_tiles[x1][y1] && arena_tiles_colors[x1][y1]==0)
                 {
                  current_color++;
                  Color_lane(x1,y1,current_color);
                  arena_tiles_colors[FLOW_START_POS.x/2+i][FLOW_START_POS.y/2+j]=current_color;
                 }
             }
}

void Map::Color_lane(int x,int y,int color)
{
 std::queue<std::pair<int,int> > que;
 que.push({x,y});
 arena_tiles_colors[x][y]=color;
 while(!que.empty())
       {
        std::pair<int,int> elem=que.front();
        que.pop();
        for(int d=0;d<4;d++)
            {
             int x1=elem.first+dirx[d],y1=elem.second+diry[d];
             if(x1>=0 && x1<ARENA_SIZE_GRAPHIC && y1>=0 && y1<ARENA_SIZE_GRAPHIC && arena_tiles[x1][y1] && arena_tiles_colors[x1][y1]==0)
                {
                 que.push({x1,y1});
                 arena_tiles_colors[x1][y1]=color;
                }
            }
       }
}
