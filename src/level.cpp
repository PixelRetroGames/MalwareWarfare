#include "level.h"
#include <typeinfo>

const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

void Level::Load(char *filename)
{
 screen_shake={0,0};
 screen_shake_intensity=3;
 screen_shake_timer.start();
 arena.Load(filename);
 arena_size=arena.Get_size();
 unit_is_placed=new std::vector<int>*[arena_size];
 for(int i=0;i<arena_size;i++)
     unit_is_placed[i]=new std::vector<int>[arena_size];
 attacker=new Attacker;
 attacker->Load(1);
 attacker->Set_available_cursor_positions(arena.Get_open_ports());
 defender=new Defender(arena_size);
 defender->Load(2);
 cpu.Load();
 cpu.Set_health(CPU_HEALTH);
 cpu.Set_screen_pos(CPU_POSITION.x,CPU_POSITION.y);
 cpu.Set_map_pos(FLOW_START_POS.x,FLOW_START_POS.y);
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         {
          if(!arena.Is_obstacle(i,j) && !cpu.Is_in_range(i,j) && i!=0 && i!=ARENA_SIZE-1 && j!=0 && j!=ARENA_SIZE-1)
             {
              defender->Set_available_cursor_position(0,{i,j},false);
              defender->Set_available_cursor_position(1,{i,j},true);
              defender->Set_available_cursor_position(2,{i,j},false);
              for(int d=0;d<4;d++)
                  {
                   int x=i+dirx[d];
                   int y=j+diry[d];
                   if(arena.Is_obstacle(x,y) && !cpu.Is_in_range(x,y) && x>=0 && x<ARENA_SIZE && y>=0 && y<ARENA_SIZE)
                      {
                       bool corner=true,one_connection=false;
                       for(int q=0;q<4 && corner;q++)
                           {
                            int x1=x+dirx[q];
                            int y1=y+diry[q];
                            if(!arena.Is_obstacle(x1,y1))
                               {
                                if(one_connection)
                                   corner=false;
                                one_connection=true;
                                bool vertical=!(q%2);
                                if(!arena.Is_obstacle(x1+vertical,y1+!vertical) && !arena.Is_obstacle(x1-vertical,y1-!vertical))
                                   corner=false;
                               }
                           }
                       if(corner)
                          defender->Set_available_cursor_position(2,{x,y},true);
                       defender->Set_available_cursor_position(0,{x,y},true);
                      }
                   /*else
                      defender->Set_available_cursor_position(1,{x,y},true);*/
                  }
             }
         }
 //defender->Print_available_pos();
}

void Level::Update_frames()
{
 attacker->Update_units_frames();
 defender->Update_units_frames();
 for(int i=0;i<units_ids.size();i++)
     {
      units[units_ids[i]].Update_frame();
     }
 arena.Update_frames();
}

const int FRAMES_PER_SECOND=60,ANIMATION_FRAMES_PER_SECOND=8;
//const int MOVEMENT_PER_SECOND=2;

void Level::Start(Texture *_screen,char *filename)
{
 music=Mix_LoadMUS("res/music/Agnet 75 -Malware Warfare Soundtrack.mp3");
 Mix_PlayMusic(music,1);
 Load_level_images();
 Load(filename);
 //#define DEBUG
 #ifndef DEBUG
 for(int i=0;i<4;i++)
     {
      if(i>0)
         {
          attacker->Get_virus(i)->Set_first_cooldown(ROUND_TIME[i-1]+FIRST_COOLDOWN);
          defender->Get_firewall(i)->Set_first_cooldown(ROUND_TIME[i-1]);
         }
      else
         {
          attacker->Get_virus(i)->Set_first_cooldown(ROUND_TIME[0]+FIRST_COOLDOWN);
          defender->Get_firewall(i)->Set_first_cooldown(ROUND_TIME[0]);
         }
     }
 #endif // DEBUG
 bool quit=false;
 Timer fps_timer;
 Timer animation_update_timer;
 animation_update_timer.start();
 game_timer.start();
 SDL_Event event;
 bool attacker_won=false,defender_won=false,game_finished=false;
 Timer game_finish_timer;
 while(!quit && (!game_finished || (game_finished && game_finish_timer.get_ticks()<GAME_FINISH_DELAY)))
       {
        fps_timer.start();
        //SDL_PumpEvents();
        while(SDL_PollEvent(&event) && !game_finished)
              {
               Update_Controllers_Events();
               Handle_Events(&event);
              }
        attacker_won=cpu.Get_health()<=0;
        defender_won=(GAME_TIME-game_timer.get_ticks())<=0;
        if((attacker_won || defender_won) && !game_finished)
           {
            game_finish_timer.start();
            game_finished=true;
            sound_manager.Play_sound(PORTAL_SOUND);
           }
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        Print(_screen);
        Regen_ram(game_timer.get_ticks());
        Update_frames();
        if(!game_finished)
           Move_units();
        if(animation_update_timer.get_ticks()>1000/ANIMATION_FRAMES_PER_SECOND)
           {
            //Move_units();
            //Update_frames();
            animation_update_timer.start();
           }
        Flip_Buffers(_screen);
        if(fps_timer.get_ticks()<1000/FRAMES_PER_SECOND)
           SDL_Delay((1000/FRAMES_PER_SECOND)-fps_timer.get_ticks());
       }
 Finish_screen(attacker_won,_screen);
 Clear_level_images();
 Clear();
 Mix_HaltMusic();
 Mix_FreeMusic(music);
}

void Level::Print_units(int x,int y,Texture *_screen)
{
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Security_service) || typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Trap))
         units[units_ids[i]].Print(x,y,_screen);
     }
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())!=typeid(Virus_cloud) &&
         typeid(*units[units_ids[i]].Get_combat_unit())!=typeid(Security_service))
         units[units_ids[i]].Print(x,y,_screen);
     }
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Virus_cloud))
         units[units_ids[i]].Print(x,y,_screen);
     }
}

void Level::Print_timer(int x,int y,Texture *_screen)
{
 int t=GAME_TIME-game_timer.get_ticks();
 char aux[TEXT_LENGTH_MAX]={NULL},aux1[TEXT_LENGTH_MAX]={NULL};
 itoa(t/60000,aux);
 strcat(aux,":");
 itoa((t%60000)/1000,aux1);
 if(strlen(aux1)==1)
    strcat(aux,"0");
 strcat(aux,aux1);
 Texture *timer_image;
 if(t/60000==0 && t%60000<GAME_CRITICAL_TIME)
    timer_image=Create_TTF_Texture(MENU_FONT_BIG,aux,GAME_TIME_CRITICAL_COLOR);
 else
    timer_image=Create_TTF_Texture(MENU_FONT_BIG,aux,GAME_TIME_COLOR);
 Apply_Texture(x,y,GAME_TIME_BACKGROUND,_screen);
 if(t/60000==0 && t%60000<GAME_CRITICAL_TIME)
    {
     if(((t%60000)/250)%2==0)
        {
         Apply_Texture(x+(GAME_TIME_BACKGROUND->w-timer_image->w)/2,y+(GAME_TIME_BACKGROUND->h-timer_image->h)/2,timer_image,_screen);
         controller[attacker->Get_id()].Vibrate(CPU_DAMAGE_VIBRATION_STRENGTH/2,30);
        }
    }
 else
    Apply_Texture(x+(GAME_TIME_BACKGROUND->w-timer_image->w)/2,y+(GAME_TIME_BACKGROUND->h-timer_image->h)/2,timer_image,_screen);
 Destroy_Texture(timer_image);
}

void Level::Print(Texture *_screen)
{
 arena_buffer=Create_Transparent_Texture(ARENA_SIZE*PIXELS_PER_INGAME_UNIT,ARENA_SIZE*PIXELS_PER_INGAME_UNIT);
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 attacker->Print_info(attacker->Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_DEFAULT_SIZE,0,_screen);
 defender->Print_info(defender->Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_DEFAULT_SIZE,0,_screen);

 /*if(screen_shake_timer.get_ticks()>SCREEN_SHAKE_SPEED)
    {
     if(cpu.Get_health()!=CPU_HEALTH)
        {
         screen_shake.first=rand()%(CPU_HEALTH-cpu.Get_health());
         screen_shake.second=rand()%(CPU_HEALTH-cpu.Get_health());
        }
    }*/
 if(screen_shaking)
    {
     if(screen_shake_timer.get_ticks()>SCREEN_SHAKE_DURATION && cpu.Get_health()>0)
        {
         screen_shake={0,0};
         screen_shaking=false;
         screen_shake_intensity=3;
        }
     else
        {
         screen_shake.first=rand()%screen_shake_intensity;
         screen_shake.second=rand()%screen_shake_intensity;
         if(screen_shake_timer.get_ticks()%10==0)
            screen_shake_intensity++;
        }
    }
 int x=screen_shake.first,y=screen_shake.second;
 arena.Print(arena_buffer,0,0);
 defender->Highlight_available_pos(0,0,arena_buffer);
 Apply_Texture(0+attacker->Get_cursor_position().second*PIXELS_PER_INGAME_UNIT,0+attacker->Get_cursor_position().first*PIXELS_PER_INGAME_UNIT,ATTACKER_CURSOR,arena_buffer);
 if(defender->Get_cursor_position().first!=-1)
    Apply_Texture(0+defender->Get_cursor_position().second*PIXELS_PER_INGAME_UNIT,0+defender->Get_cursor_position().first*PIXELS_PER_INGAME_UNIT,DEFENDER_CURSOR,arena_buffer);
 Print_units(0,0,arena_buffer);
 effect_manager.Print(arena_buffer);
 effect_manager.Update();
 Apply_Texture({x,y,arena_buffer->w,arena_buffer->h},arena_buffer,
               {MENU_OPTION_BACKGROUND->w,0,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT},_screen);

 cpu.Print(MENU_OPTION_BACKGROUND->w+x,y,_screen);
 cpu_damage.Print(x,y,_screen);
 cpu_damage.Update();
 Print_timer((_screen->w-GAME_TIME_BACKGROUND->w)/2,0,_screen);
 Destroy_Texture(arena_buffer);
 if(CONTROLLER_SCHEME==CONTROLLER_SCHEME_CONTROLLERS)
    defender->Print_cursor(_screen);
}

bool Level::Is_empty(int x,int y)
{
 return unit_is_placed[x][y].empty();
}

void Level::Add_unit(int x,int y,int id)
{
 unit_is_placed[x][y].push_back(id);
}

void Level::Remove_unit(int x,int y,int id)
{
 for(int i=0;i<unit_is_placed[x][y].size();i++)
     {
      if(unit_is_placed[x][y][i]==id)
         {
          unit_is_placed[x][y].erase(unit_is_placed[x][y].begin()+i);
          return;
         }
     }
}

void Level::Remove_unit(int pos)
{
 std::pair<int,int> _pos=units[units_ids[pos]].Get_map_pos();
 if(typeid(*units[units_ids[pos]].Get_combat_unit())==typeid(Glitch))
    glitch_id.erase(_pos);
 else
    Remove_unit(_pos.first,_pos.second,units_ids[pos]);
 attacker->Unlock_cursor_pos(_pos);
 if(/*_pos.first!=0 && _pos.first!=ARENA_SIZE-1 &&
    _pos.second!=0 && _pos.second!=ARENA_SIZE-1 &&*/
    !cpu.Is_in_range(_pos.first,_pos.second) &&
    units[units_ids[pos]].Is_firewall())
    defender->Set_available_cursor_position(Get_firewall_type(units[units_ids[pos]].Get_combat_unit()),{_pos.first,_pos.second},true);
 int id=units_ids[pos];
 if(units[units_ids[pos]].Is_firewall())
    {
     if(typeid(*units[units_ids[pos]].Get_combat_unit())==typeid(Trap))
        defense_units_on_lane.erase(_pos);
     else
        Remove_unit(_pos.first,_pos.second,units_ids[pos]);
    }
 units[units_ids[pos]].Clear();
 units.erase(units_ids[pos]);
 units_ids.erase(units_ids.begin()+pos);
}

void Level::Move_unit(int i,int x,int y)
{
 if(units[units_ids[i]].Is_firewall())
    return;
 std::pair<int,int> pos=units[units_ids[i]].Get_map_pos();
 if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Glitch))
    {
     glitch_id.erase(pos);
     glitch_id[{x,y}]=units_ids[i];
    }
 else
    {
     Remove_unit(pos.first,pos.second,units_ids[i]);
     Add_unit(x,y,units_ids[i]);
    }
 units[units_ids[i]].Set_map_pos(x,y);
 units[units_ids[i]].Set_state(STATE_WALKING);
}

void Level::Move_unit_id(int i,int x,int y)
{
 if(units[i].Is_firewall())
    return;
 std::pair<int,int> pos=units[i].Get_map_pos();
 if(typeid(*units[i].Get_combat_unit())==typeid(Glitch))
    {
     glitch_id.erase(pos);
     glitch_id[{x,y}]=i;
    }
 else
    {
     Remove_unit(pos.first,pos.second,i);
     Add_unit(x,y,i);
    }
 units[i].Set_map_pos(x,y);
 units[i].Set_state(STATE_WALKING);
}

void Level::Move_units()
{
 for(int i=0;i<units_ids.size();i++)
     {
      if(units[units_ids[i]].Is_dead())
         {
          bool md=false;
          if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
             md=true;
          Unit_trigger_death_effect(i);
          if(md)
             i--;
          continue;
         }
      Unit_trigger_special_effect(i);
      std::pair<int,int> pos=units[units_ids[i]].Get_map_pos();
      if(units[units_ids[i]].Is_firewall())
         {
          /*bool attacking=false;
          for(int d=0;d<4;d++)
              {
               if(pos.first+dirx[d]>=0 && pos.first+dirx[d]<ARENA_SIZE && pos.second+diry[d]>=0 && pos.second+diry[d]<ARENA_SIZE &&
                  unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]!=-1 &&
                  units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]].Is_virus())
                  attacking=true;
              }*/
          if(units[units_ids[i]].Get_state()==STATE_ATTACKING)
             if(units[units_ids[i]].Phase_finished())
                units[units_ids[i]].Set_state(STATE_IDLE);
          if(units[units_ids[i]].Phase_finished() && units[units_ids[i]].Get_state()!=STATE_ATTACKING && units[units_ids[i]].Get_state()!=STATE_DYING)
             Check_unit_fight(i);
         }
      if(units[units_ids[i]].Is_firewall() || typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Virus_cloud))
         continue;
      int d=arena.Get_flow_direction(pos.first,pos.second);
      //units[units_ids[i]].Set_angle(d);
      bool phase_finished=units[units_ids[i]].Phase_finished();
      if(phase_finished && units[units_ids[i]].Get_state()!=STATE_ATTACKING && units[units_ids[i]].Get_state()!=STATE_DYING && Check_unit_fight(i))
         {
          units[units_ids[i]].Set_angle(d);
          //Units_fight(units_ids[i],unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]);
          /*if(units[units_ids[i]].Is_dead())
             {
              bool md=false;
              if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
                 md=true;
              Unit_trigger_death_effect(i);
              if(md)
                 i--;
              //Remove_unit(i);
             }*/
         }
      else
         {
          //bool sq=units[units_ids[i]].Phase_finished();
          if(d!=-1 && (Is_empty(pos.first+dirx[d],pos.second+diry[d]) || typeid(*units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]][0]].Get_combat_unit())==typeid(Trap) ||
                       true) &&
             phase_finished)
             {
              if(pos.first==0 || pos.second==0 || pos.first==ARENA_SIZE-1 || pos.second==ARENA_SIZE-1)
                 attacker->Unlock_cursor_pos(pos);
              units[units_ids[i]].Set_angle(d);
              Move_unit(i,pos.first+dirx[d],pos.second+diry[d]);
              Check_if_CPU_damage({pos.first+dirx[d],pos.second+diry[d]},i);
              /*if(cpu.Is_in_range(pos.first+dirx[d],pos.second+diry[d]))
                 {
                  sound_manager.Play_sound(CPU_DAMAGE_SOUND);
                  cpu_damage.Add_effect(0,MENU_OPTION_BACKGROUND->w+CPU_POSITION.x*PIXELS_PER_INGAME_UNIT,CPU_POSITION.y*PIXELS_PER_INGAME_UNIT,CPU_DAMAGE_EFFECT);
                  cpu.Set_health(cpu.Get_health()-1);
                  screen_shake_timer.start();
                  screen_shaking=true;
                  controller[defender->Get_id()].Vibrate(CPU_DAMAGE_VIBRATION_STRENGTH,SCREEN_SHAKE_DURATION);
                  if(cpu.Get_health()==0)
                     cpu_damage.Add_effect(1,MENU_OPTION_BACKGROUND->w+(CPU_POSITION.x-4)*PIXELS_PER_INGAME_UNIT,(CPU_POSITION.y-4)*PIXELS_PER_INGAME_UNIT,CPU_EXPLOSION_EFFECT);
                  bool md=false;
                  if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
                     md=true;
                  Unit_trigger_death_effect(i);
                  Remove_unit(i);
                  if(md)
                     Remove_unit(i);
                 }*/
             }
          /*else
             if(units[units_ids[i]].Phase_finished())
                units[units_ids[i]].Set_state(STATE_IDLE);*/
         }
     }
}

bool Level::Check_unit_fight(int id)
{
 std::pair<int,int> pos=units[units_ids[id]].Get_map_pos();
 int d=arena.Get_flow_direction(pos.first,pos.second);
 bool ret=false;
 if(units[units_ids[id]].Is_virus())
    {
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Glitch))
        return false;
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Malware) || typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trojan))
        {
         pos.first+=dirx[d];
         pos.second+=diry[d];
         d=arena.Get_flow_direction(pos.first,pos.second);
        }

    if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Malware))
       {
        for(int r=0;r<units[units_ids[id]].Get_combat_unit()->Get_radius();r++)
            {
             for(int dir=0;dir<4;dir++)
                 {
                  if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                     !Is_empty(pos.first+dirx[dir],pos.second+diry[dir]) && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Is_firewall())
                     {
                      Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0],true);
                      ret=ret || (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Get_combat_unit())!=typeid(Security_service));
                     }
                 }
             pos.first+=dirx[d];
             pos.second+=diry[d];
             d=arena.Get_flow_direction(pos.first,pos.second);
            }
        if(ret)
           {
            pos=units[units_ids[id]].Get_map_pos();
            d=arena.Get_flow_direction(pos.first,pos.second);
            pos.first+=dirx[d];
            pos.second+=diry[d];
            int r=units[units_ids[id]].Get_combat_unit()->Get_radius();
            effect_manager.Add_effect(2,(pos.second-r)*PIXELS_PER_INGAME_UNIT,
                                      (pos.first-r)*PIXELS_PER_INGAME_UNIT,LEVEL_EXPLOSION);
           }
       }
     else
        {
         for(int dir=0;dir<4;dir++)
             {
              if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                 !Is_empty(pos.first+dirx[dir],pos.second+diry[dir]) && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Is_firewall())
                 {
                  Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0],true);
                  ret=ret ||  (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Get_combat_unit())!=typeid(Security_service));
                 }
             }
        }
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trojan))
        {
         for(int dir=0;dir<4;dir++)
             {
              if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                 !Is_empty(pos.first+dirx[dir],pos.second+diry[dir]) && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Is_firewall())
                 {
                  Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0],true);
                  ret=ret ||  (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]][0]].Get_combat_unit())!=typeid(Security_service));
                 }
             }
        }
    }
 else
    {
     if(!units[units_ids[id]].Is_stunned())
        {
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Firewall_plus))
            {
             int r=units[units_ids[id]].Get_combat_unit()->Get_range();
             int _x=-1,_y=-1,dist=ARENA_SIZE*ARENA_SIZE;
             for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r+1);i++)
                 {
                  for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r+1);j++)
                      {
                       if(!Is_empty(i,j))
                          {
                           for(int q=0;q<unit_is_placed[i][j].size();q++)
                               {
                                if(units[unit_is_placed[i][j][q]].Is_virus())
                                   {
                                    if(arena.Get_distance_to_CPU(i,j)<dist)
                                       {
                                        dist=arena.Get_distance_to_CPU(i,j);
                                        _x=i;
                                        _y=j;
                                       }
                                   }
                               }
                          }
                       if(glitch_id.count({i,j})!=0)
                          {
                           if(arena.Get_distance_to_CPU(i,j)<dist)
                              {
                               dist=arena.Get_distance_to_CPU(i,j);
                               _x=i;
                               _y=j;
                              }
                          }
                      }
                 }
             if(_x!=-1 && _y!=-1)
                {
                 int vertical=_x-pos.first,horizontal=_y-pos.second;
                 if(vertical==0 || horizontal==0)
                    {
                     int d=0;
                     if(horizontal==0)
                        d=vertical>0?0:2;
                     if(vertical==0)
                        d=horizontal>0?1:3;
                     effect_manager.Add_effect(0,_y*PIXELS_PER_INGAME_UNIT,
                                               _x*PIXELS_PER_INGAME_UNIT,FIREWALL_ATTACK_PERPENDICULAR_EFFECT[d]);
                    }
                 else
                    {
                     int d=0;
                     if(vertical>0)
                        d=horizontal>0?1:0;
                     else
                        d=horizontal>0?2:3;
                     effect_manager.Add_effect(0,_y*PIXELS_PER_INGAME_UNIT,
                                               _x*PIXELS_PER_INGAME_UNIT,FIREWALL_ATTACK_OBLIQUE_EFFECT[d]);
                    }
                 for(int q=0;q<unit_is_placed[_x][_y].size();q++)
                     {
                      if(units[unit_is_placed[_x][_y][q]].Is_virus())
                         Units_fight(unit_is_placed[_x][_y][q],units_ids[id],false);
                     }
                 if(glitch_id.count({_x,_y})!=0)
                    Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                 ret=true;
                 sound_manager.Play_sound(FIREWALL_ATTACK_SOUND);
                }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Slow_Tower))
            {
             int r=units[units_ids[id]].Get_combat_unit()->Get_range();
             for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r+1);i++)
                 {
                  for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r+1);j++)
                      {
                       if(arena.Check_if_valid_pos(i,j) && (!Is_empty(i,j) || glitch_id.count({i,j})!=0))
                          {
                           for(int q=0;q<unit_is_placed[i][j].size();q++)
                               if(units[unit_is_placed[i][j][q]].Is_virus())
                                  {
                                   Units_fight(unit_is_placed[i][j][q],units_ids[id],false);
                                   ret=true;
                                  }
                           if(glitch_id.count({i,j})!=0)
                              {
                               Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                               ret=true;
                              }
                          }
                      }
                 }
             if(ret)
                {
                 sound_manager.Play_sound(SLOW_SOUND);
                 pos=units[units_ids[id]].Get_map_pos();
                 effect_manager.Add_effect(4,(pos.second-r)*PIXELS_PER_INGAME_UNIT,
                                           (pos.first-r)*PIXELS_PER_INGAME_UNIT,SLOW_TOWER_ATTACK_EFFECT);
                }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Firewall))
            {
             for(d=0;d<4 && !ret;d++)
                 {
                  if(!Is_empty(pos.first+dirx[d],pos.second+diry[d]) || glitch_id.count({pos.first+dirx[d],pos.second+diry[d]})!=0)
                     {
                      for(int q=0;q<unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]].size();q++)
                          if(units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]][q]].Is_virus())
                             {
                              Units_fight(unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]][q],units_ids[id],false);
                              ret=true;
                             }
                      if(glitch_id.count({pos.first+dirx[d],pos.second+diry[d]})!=0)
                         {
                          Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                          ret=true;
                         }
                     }
                 }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trap) || typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Security_service))
            {
             if(!Is_empty(pos.first,pos.second) || glitch_id.count(pos)!=0)
                {
                 for(int q=0;q<unit_is_placed[pos.first][pos.second].size();q++)
                     if(units[unit_is_placed[pos.first][pos.second][q]].Is_virus())
                        {
                         Units_fight(unit_is_placed[pos.first][pos.second][q],units_ids[id],false);
                        }
                 if(glitch_id.count({pos})!=0)
                    Units_fight(glitch_id[pos],units_ids[id],false);
                }
            }
        }
    }
 return ret;
}

void Level::Units_fight(int virus_id,int firewall_id,bool virus_attacked)
{
 Field_unit *virus=&units[virus_id],*firewall=&units[firewall_id];
 bool damage_taken=false;
 int bonus_damage=rand()%3-1;
 if(!virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Antivirus_scanner))
    {
     firewall->Set_state(STATE_ATTACKING);
     virus->Take_damage(firewall->Get_combat_unit()->Get_damage());
     damage_taken=firewall->Get_combat_unit()->Get_damage()!=0;
     if(damage_taken && (firewall->Get_combat_unit()->Get_damage()+bonus_damage>0 || typeid(*firewall->Get_combat_unit())==typeid(Slow_Tower)))
        virus->Take_damage(bonus_damage);
     if(typeid(*firewall->Get_combat_unit())==typeid(Firewall_plus))
        units[firewall_id].Set_state(STATE_ATTACKING);
    }
 if(virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     sound_manager.Play_sound(VIRUS_ATTACK_SOUND);
     firewall->Take_damage(virus->Get_combat_unit()->Get_damage());
     damage_taken=damage_taken || virus->Get_combat_unit()->Get_damage()!=0;
     if(damage_taken && virus->Get_combat_unit()->Get_damage()+bonus_damage>0)
        firewall->Take_damage(bonus_damage);
     /*effect_manager.Add_effect(0,firewall->Get_map_pos().second*PIXELS_PER_INGAME_UNIT,
                               firewall->Get_map_pos().first*PIXELS_PER_INGAME_UNIT,LEVEL_DAMAGE);*/
    }
 if(!virus_attacked && (typeid(*firewall->Get_combat_unit())==typeid(Security_service) || typeid(*firewall->Get_combat_unit())==typeid(Trap)))
    firewall->Take_damage(1);
 if(!virus_attacked && typeid(*firewall->Get_combat_unit())==typeid(Security_service) /*&& transformed_virus.count(firewall->Get_map_pos())==0*/)
    {
     //units[virus_id].Set_map_pos(firewall->Get_map_pos());
     int x=(rand()%4)%(std::max(1,virus->Get_combat_unit()->Get_id()==4?0:virus->Get_combat_unit()->Get_id()));
     units[virus_id].Set_unit(x==0?attacker->Get_basic_virus():attacker->Get_virus(x));
     units[virus_id].Set_damage_taken(0);
     units[virus_id].Set_state(STATE_ATTACKING);
     units[virus_id].Set_state(STATE_IDLE);
     int dir=arena.Get_flow_direction(virus->Get_map_pos());
     units[virus_id].Set_angle(dir);
     Move_unit_id(virus_id,virus->Get_map_pos().first+dirx[dir],virus->Get_map_pos().second+diry[dir]);
     Check_if_CPU_damage({virus->Get_map_pos().first+dirx[dir],virus->Get_map_pos().second+diry[dir]},virus_id);
     sound_manager.Play_sound(PORTAL_SOUND);
    }
 if(virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     units[virus_id].Set_state(STATE_ATTACKING);
    }
 if(typeid(*virus->Get_combat_unit())==typeid(Trojan) && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     firewall->Stun(virus->Get_combat_unit()->Get_stun_time());
     sound_manager.Play_sound(GLITCH_SOUND);
    }
 if(typeid(*firewall->Get_combat_unit())==typeid(Slow_Tower) && !virus->Is_slowed())
    {
     virus->Slow(firewall->Get_combat_unit()->Get_slow_time());
    }

 if(false && damage_taken)
    sound_manager.Play_sound(UNIT_DAMAGE_SOUND);
}

void Level::Unit_trigger_death_effect(int _pos)
{
 units[units_ids[_pos]].Set_state(STATE_DYING);
 if(!units[units_ids[_pos]].Phase_finished())
    return;

 /*if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Malware))
    {
     int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
     int r=units[units_ids[_pos]].Get_combat_unit()->Get_radius();
     effect_manager.Add_effect(2,(y-r+1)*PIXELS_PER_INGAME_UNIT,(x-r+1)*PIXELS_PER_INGAME_UNIT,LEVEL_EXPLOSION);
     bool damaged_cpu=false;
     for(int i=std::max(x-r,0);i<=std::min(x+r,ARENA_SIZE-1);i++)
         for(int j=std::max(y-r,0);j<=std::min(y+r,ARENA_SIZE-1);j++)
             {
              if(cpu.Is_in_range(i,j) && !damaged_cpu)
                 {
                  cpu.Set_health(cpu.Get_health()-units[units_ids[_pos]].Get_combat_unit()->Get_damage());
                  damaged_cpu=true;
                 }
              if(unit_is_placed[i][j]!=-1 && unit_is_placed[i][j]!=units_ids[_pos] && units[unit_is_placed[i][j]].Is_firewall())
                 {
                  units[unit_is_placed[i][j]].Take_damage(units[units_ids[_pos]].Get_combat_unit()->Get_damage());
                 }
             }
    }*/
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Malware_defender))
    {
     units[units_ids[_pos]].Set_unit(attacker->Get_basic_virus());
     units[units_ids[_pos]].Set_damage_taken(0);
     Remove_unit(units[units_ids[_pos]].Get_map_pos().first,units[units_ids[_pos]].Get_map_pos().second,units_ids[_pos]);
     Add_unit(units[units_ids[_pos]].Get_map_pos().first,units[units_ids[_pos]].Get_map_pos().second,units_ids[_pos]);
     defender->Set_available_cursor_position(Get_firewall_type(units[units_ids[_pos]].Get_combat_unit()),units[units_ids[_pos]].Get_map_pos(),0);
     //defender->Set_available_cursor_position(Get_firewall_type(units[units_ids[_pos]].Get_combat_unit()),units[units_ids[_pos]].Get_map_pos(),2);
     if(units[units_ids[_pos]].Get_map_pos()==attacker->Get_cursor_position())
        attacker->Lock_cursor_pos(units[units_ids[_pos]].Get_map_pos());

     return;
    }
 Remove_unit(_pos);
}

void Level::Unit_trigger_special_effect(int _pos)
{
 if(units[units_ids[_pos]].Is_stunned())
    return;
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Healer))
    {
     if(!units[units_ids[_pos]].Triggered_special_effect())
        {
         if(units[units_ids[_pos]].Special_effect_finished(2000))
            units[units_ids[_pos]].Set_state(STATE_IDLE);
         return;
        }
     units[units_ids[_pos]].Start_special_effect_timer();
     units[units_ids[_pos]].Set_state(STATE_ATTACKING);
     int r=2;
     std::pair<int,int> pos=units[units_ids[_pos]].Get_map_pos();
     for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r);i++)
         for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r);j++)
             {
              for(int q=0;q<unit_is_placed[i][j].size();q++)
                  if(units[unit_is_placed[i][j][q]].Is_firewall())
                     units[unit_is_placed[i][j][q]].Take_damage(-1);
             }
    }
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Antivirus_scanner))
    {
     bool is_triggered=false;
     //if(!units[units_ids[_pos]].Is_triggered())
        {
         int flow_dir;
         for(int i=0;i<4;i++)
             {
              int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
              if(dir_reversed[i]==arena.Get_flow_direction(x,y))
                 continue;
              int _x=x+dirx[dir_reversed[i]],_y=y+diry[dir_reversed[i]];
              if(_x>=0 && _x<ARENA_SIZE && _y>=0 && _y<ARENA_SIZE && !cpu.Is_in_range(_x,_y) && !arena.Is_obstacle(_x,_y))
                 {
                  flow_dir=i;
                  break;
                 }
             }
         flow_dir=dir_reversed[flow_dir];
         std::pair<int,int> pos;
         pos={units[units_ids[_pos]].Get_map_pos().first+dirx[flow_dir],units[units_ids[_pos]].Get_map_pos().second+diry[flow_dir]};
         while(!arena.Is_obstacle(pos.first,pos.second) && !is_triggered)
               {
                if(!Is_empty(pos.first,pos.second))
                   is_triggered=true;
                pos.first+=dirx[flow_dir];
                pos.second+=diry[flow_dir];
               }

         if(!is_triggered)
            return;
        }
     if(!units[units_ids[_pos]].Triggered_special_effect())
        {
         if(units[units_ids[_pos]].Special_effect_finished(ANTIVIRUS_SCANNER_SPECIAL_EFFECT_DURATION))
            units[units_ids[_pos]].Set_state(STATE_IDLE);
         return;
        }
     units[units_ids[_pos]].Start_special_effect_timer();
     units[units_ids[_pos]].Set_state(STATE_ATTACKING);
     int flow_dir;
     for(int i=0;i<4;i++)
         {
          int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
          if(dir_reversed[i]==arena.Get_flow_direction(x,y))
             continue;
          int _x=x+dirx[dir_reversed[i]],_y=y+diry[dir_reversed[i]];
          if(_x>=0 && _x<ARENA_SIZE && _y>=0 && _y<ARENA_SIZE && !cpu.Is_in_range(_x,_y) && !arena.Is_obstacle(_x,_y))
             {
              flow_dir=i;
              break;
             }
         }
     flow_dir=dir_reversed[flow_dir];
     effect_manager.Add_effect(1,units[units_ids[_pos]].Get_map_pos().second*PIXELS_PER_INGAME_UNIT,
                               units[units_ids[_pos]].Get_map_pos().first*PIXELS_PER_INGAME_UNIT,ELECTROSHOCK_EFFECT[flow_dir]);
     units[units_ids[_pos]].Set_angle(flow_dir);
     std::pair<int,int> pos;
     pos={units[units_ids[_pos]].Get_map_pos().first+dirx[flow_dir],units[units_ids[_pos]].Get_map_pos().second+diry[flow_dir]};
     while(!arena.Is_obstacle(pos.first,pos.second))
           {
            for(int q=0;q<unit_is_placed[pos.first][pos.second].size();q++)
                {
                 if(units[unit_is_placed[pos.first][pos.second][q]].Is_virus() && typeid(*units[unit_is_placed[pos.first][pos.second][q]].Get_combat_unit())==typeid(Malware_defender))
                    break;
                 if(units[unit_is_placed[pos.first][pos.second][q]].Is_virus() && typeid(*units[unit_is_placed[pos.first][pos.second][q]].Get_combat_unit())!=typeid(Virus_cloud))
                    {
                     int bonus_damage=rand()%3-1;
                     if(units[units_ids[_pos]].Get_combat_unit()->Get_damage()+bonus_damage<=0)
                        bonus_damage=0;
                     units[unit_is_placed[pos.first][pos.second][q]].Take_damage(units[units_ids[_pos]].Get_combat_unit()->Get_damage()+bonus_damage);
                    }
                }
            effect_manager.Add_effect(1,pos.second*PIXELS_PER_INGAME_UNIT,
                                      pos.first*PIXELS_PER_INGAME_UNIT,LEVEL_ELECTROSHOCK);
            pos.first+=dirx[flow_dir];
            pos.second+=diry[flow_dir];
           }
     sound_manager.Play_sound(LASER_SOUND);
     //units[units_ids[_pos]].Take_damage(1);
    }
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Virus_cloud))
    {
     if(!units[units_ids[_pos]].Ready_to_spawn())
        return;
     units[units_ids[_pos]].Start_spawn_timer();
     int d=arena.Get_flow_direction(units[units_ids[_pos]].Get_map_pos());
     std::pair<int,int> pos1=units[units_ids[_pos]].Get_map_pos(),pos;
     pos=pos1;
     pos.first+=dirx[d];
     pos.second+=diry[d];
     //if(unit_is_placed[pos.first][pos.second]==-1)
        {
         Add_virus(pos1,4);
         for(int q=0;q<unit_is_placed[pos.first][pos.second].size();q++)
             units[unit_is_placed[pos.first][pos.second][q]].Set_angle(arena.Get_flow_direction(pos1));
         units[units_ids[_pos]].Take_damage(1);
        }
    }
}

void Level::Add_virus(std::pair<int,int> pos,int virus_id)
{
 Field_unit aux;
 aux.Set_map_pos(pos);
 aux.Set_unit(attacker->Get_virus(virus_id));
 aux.Set_damage_taken(0);
 aux.Set_angle(arena.Get_flow_direction(aux.Get_map_pos().first,aux.Get_map_pos().second));
 int i=0;
 while(units.count(i)!=0)
       i++;

 units[i]=aux;
 units_ids.push_back(i);
 if(typeid(*aux.Get_combat_unit())==typeid(Glitch))
    glitch_id[pos]=virus_id;
 else
    Add_unit(aux.Get_map_pos().first,aux.Get_map_pos().second,i);
 defender->Set_available_cursor_position(Get_firewall_type(aux.Get_combat_unit()),aux.Get_map_pos(),2);
 if(aux.Get_map_pos()==attacker->Get_cursor_position())
    attacker->Lock_cursor_pos(aux.Get_map_pos());
 sound_manager.Play_sound(VIRUS_PLACEMENT_SOUND);
}

void Level::Handle_Events(SDL_Event *event)
{
 int virus_id=attacker->Handle_Events();
 if(virus_id!=-1)
    {
     attacker->Set_ram(attacker->Get_ram()-attacker->Get_virus(virus_id)->Get_ram_cost());
     Add_virus(attacker->Get_cursor_position(),virus_id);
    }
 int firewall_id=defender->Handle_Events(MENU_OPTION_BACKGROUND->w,0,event);
 if(firewall_id!=-1)
    {
     defender->Set_ram(defender->Get_ram()-defender->Get_firewall(firewall_id)->Get_ram_cost());
     Field_unit aux;
     aux.Set_map_pos(defender->Get_cursor_position());
     aux.Set_unit(defender->Get_firewall(firewall_id));
     aux.Set_damage_taken(0);
     std::pair<int,int> pos=aux.Get_map_pos();
     for(int i=0;i<4;i++)
         {
          if(arena.Get_flow_direction(pos.first,pos.second)==i)
             continue;
          int x=pos.first+dirx[i];
          int y=pos.second+diry[i];
          if(x>=0 && x<ARENA_SIZE && y>=0 && y<ARENA_SIZE && !arena.Is_obstacle(x,y))
             {
              aux.Set_angle(i);
              break;
             }
         }
     //aux.Set_angle(dir_reversed[arena.Get_flow_direction(aux.Get_map_pos().first,aux.Get_map_pos().second)]);
     int i=0;
     while(units.count(i)!=0)
           i++;
     units[i]=aux;
     units_ids.push_back(i);
     if(typeid(*units[i].Get_combat_unit())==typeid(Trap) || typeid(*units[i].Get_combat_unit())==typeid(Security_service))
        defense_units_on_lane[pos]=i;
     else
        Add_unit(defender->Get_cursor_position().first,defender->Get_cursor_position().second,i);
     defender->Set_available_cursor_position(Get_firewall_type(units[i].Get_combat_unit()),defender->Get_cursor_position(),2);
     attacker->Lock_cursor_pos(defender->Get_cursor_position());
     sound_manager.Play_sound(FIREWALL_PLACEMENT_SOUND);
    }
}

void Level::Clear()
{
 for(int i=0;i<arena_size;i++)
     for(int j=0;j<arena_size;j++)
         unit_is_placed[i][j].clear();
 for(int i=0;i<arena_size;i++)
     {
      delete[] unit_is_placed[i];
     }
 delete[] unit_is_placed;
 defense_units_on_lane.clear();
 std::vector<int>().swap(units_ids);
 for(std::map<int,Field_unit>::iterator i=units.begin();i!=units.end();i++)
     i->second.Clear();
 units.clear();
 effect_manager.Clear();
 cpu_damage.Clear();
 cpu.Clear();
 arena.Clear();
 attacker->Clear();
 defender->Clear();
}

void Level::Regen_ram(int game_time)
{
 attacker->Regen_ram(game_time);
 defender->Regen_ram(game_time);
}

void Level::Finish_screen(bool attacker_won,Texture *_screen)
{
 Print_finish_screen(attacker_won,_screen);
 Flip_Buffers(_screen);
 bool quit=false;
 while(!quit)
       {
        SDL_PumpEvents();
        quit=keystates[SDL_SCANCODE_ESCAPE];
        Flip_Buffers(_screen);
       }
}

void Level::Print_finish_screen(bool attacker_won,Texture *_screen)
{
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 Texture *aux=Create_TTF_Texture(MENU_FONT_BIG,attacker_won?"Hacker won!":"Defender won!",{255,255,255});
 Apply_Texture((_screen->w-aux->w)/2,(_screen->h-aux->h)/2,aux,_screen);
 Destroy_Texture(aux);
 aux=Create_TTF_Texture(MENU_FONT_BIG,"Press ESCAPE to exit...",{255,255,255});
 Apply_Texture((_screen->w-aux->w)/2,_screen->h-_screen->h/4-aux->h,aux,_screen);
 Destroy_Texture(aux);
}

void Level::Check_if_CPU_damage(std::pair<int,int> pos,int i)
{
 if(cpu.Is_in_range(pos))
    {
     sound_manager.Play_sound(CPU_DAMAGE_SOUND);
     cpu_damage.Add_effect(0,MENU_OPTION_BACKGROUND->w+CPU_POSITION.x*PIXELS_PER_INGAME_UNIT,CPU_POSITION.y*PIXELS_PER_INGAME_UNIT,CPU_DAMAGE_EFFECT);
     cpu.Set_health(cpu.Get_health()-1);
     screen_shake_timer.start();
     screen_shaking=true;
     controller[defender->Get_id()].Vibrate(CPU_DAMAGE_VIBRATION_STRENGTH,SCREEN_SHAKE_DURATION);
     if(cpu.Get_health()==0)
        cpu_damage.Add_effect(1,MENU_OPTION_BACKGROUND->w+(CPU_POSITION.x-4)*PIXELS_PER_INGAME_UNIT,(CPU_POSITION.y-4)*PIXELS_PER_INGAME_UNIT,CPU_EXPLOSION_EFFECT);
     bool md=false;
     if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
        md=true;
     Unit_trigger_death_effect(i);
     Remove_unit(i);
     if(md)
        Remove_unit(i);
    }
}
