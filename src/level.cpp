#include "level.h"

int Level::Get_tile_from_neighbors(bool *neighbors)
{
 int id=0;
 for(int i=0;i<4;i++)
     {
      id=id*2+neighbors[i];
     }
 return id;
}

void Level::Load_new_tile(int _id)
{
 char aux[TEXT_LENGTH_MAX],aux1[TEXT_LENGTH_MAX];
 strcpy(aux,"res/tiles/");
 itoa(_id,aux1);
 strcat(aux,aux1);
 strcat(aux,".png");
 tiles[_id]=Load_Transparent_Texture(aux);
 if(tiles[_id]==NULL)
    printf("Aci");
}

const SDL_Rect FLOW_START_POS={4,4,0,0};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};
void Level::Create_arena_flow()
{
 std::queue<std::pair<int,int>> que;
 arena_flow_direction[FLOW_START_POS.x][FLOW_START_POS.y]=0;
 que.push({FLOW_START_POS.x,FLOW_START_POS.y});
 while(!que.empty())
       {
        int x,y;
        x=que.front().first;
        y=que.front().second;
        que.pop();
        for(int i=0;i<4;i++)
            {
             if(x+dirx[i]>=0 && x+dirx[i]<ARENA_SIZE && y+diry[i]>=0 && y+diry[i]<ARENA_SIZE && arena[x+dirx[i]][y+diry[i]] &&
                arena_flow_direction[x+dirx[i]][y+diry[i]]==-1)
                {
                 arena_flow_direction[x+dirx[i]][y+diry[i]]=dir_reversed[i];
                 que.push({x+dirx[i],y+diry[i]});
                }
            }
       }
}

void Level::Load(char *filename)
{
 FILE *in=fopen(filename,"r");
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         fscanf(in,"%d ",&arena[i][j]);
 fclose(in);

 Load_new_tile(0);
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         {
          arena_flow_direction[i][j]=-1;
          if(!arena[i][j])
             {
              arena_tiles[i][j]=0;
              continue;
             }
          bool neighbors[4]={0,0,0,0};
          for(int q=0;q<4;q++)
              {
               if(i+dirx[q]>=0 && i+dirx[q]<ARENA_SIZE && j+diry[q]>=0 && j+diry[q]<ARENA_SIZE)
                  neighbors[q]=arena[i+dirx[q]][j+diry[q]];
              }
          arena_tiles[i][j]=Get_tile_from_neighbors(neighbors);
          if(tiles.count(arena_tiles[i][j])==0)
             Load_new_tile(arena_tiles[i][j]);
         }
 Create_arena_flow();

 attacker.Load(1);
 defender.Load(2);
}

const int TILE_SIZE=64;

void Level::Print_Map(Texture *_screen,int x,int y)
{
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         //Apply_Texture(j*TILE_SIZE+x,i*TILE_SIZE+y,tiles[arena_tiles[i][j]],_screen);
         Apply_Texture(arena_tiles_frame*TILE_SIZE,0,j*TILE_SIZE+x,i*TILE_SIZE+y,TILE_SIZE,TILE_SIZE,tiles[arena_tiles[i][j]],_screen);
}

const int ARENA_TILES_FRAMES=1;

void Level::Update_Map_frames()
{
 arena_tiles_frame++;
 arena_tiles_frame%=ARENA_TILES_FRAMES;
}

void Level::Update_frames()
{
 attacker.Update_units_frames();
 defender.Update_units_frames();
 Update_Map_frames();
}

const int FRAMES_PER_SECOND=60,ANIMATION_FRAMES_PER_SECOND=10;

void Level::Start(Texture *_screen,char *filename)
{
 Load(filename);
 bool quit=false;
 Timer fps_timer;
 Timer animation_update_timer;
 animation_update_timer.start();
 while(!quit)
       {
        fps_timer.start();
        SDL_PumpEvents();
        Update_Controllers_Events();
        Handle_Events();
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        Print(_screen);
        if(animation_update_timer.get_ticks()>1000/ANIMATION_FRAMES_PER_SECOND)
           {
            Update_frames();
            animation_update_timer.start();
           }
        Flip_Buffers(_screen);
        if(fps_timer.get_ticks()<1000/FRAMES_PER_SECOND)
           SDL_Delay((1000/FRAMES_PER_SECOND)-fps_timer.get_ticks());
       }
 Clear();
}

void Level::Print(Texture *_screen)
{
 attacker.Print_info(attacker.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+TILE_SIZE*ARENA_SIZE,0,_screen);
 defender.Print_info(defender.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+TILE_SIZE*ARENA_SIZE,0,_screen);
 Print_Map(_screen,MENU_OPTION_BACKGROUND->w,0);
}

void Level::Handle_Events()
{
 attacker.Handle_Events();
 defender.Handle_Events();
}

void Level::Clear()
{
 for(std::map<int,Texture*>::iterator i=tiles.begin();i!=tiles.end();i++)
     Destroy_Texture(i->second);
 tiles.clear();
 attacker.Clear();
}
