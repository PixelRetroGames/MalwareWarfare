#include "level.h"

const SDL_Rect FLOW_START_POS={4,4,0,0};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

void Level::Load(char *filename)
{
 arena.Load(filename);
 attacker.Load(1);
 defender.Load(2);
}

void Level::Update_frames()
{
 attacker.Update_units_frames();
 defender.Update_units_frames();
 arena.Update_frames();
}

const int FRAMES_PER_SECOND=60,ANIMATION_FRAMES_PER_SECOND=10;

void Level::Start(Texture *_screen,char *filename)
{
 Load_level_images();
 Load(filename);
 bool quit=false;
 Timer fps_timer;
 Timer animation_update_timer;
 animation_update_timer.start();
 while(!quit)
       {
        fps_timer.start();
        SDL_PumpEvents();
        Update_Controllers_Events();
        Handle_Events();
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        Print(_screen);
        if(animation_update_timer.get_ticks()>1000/ANIMATION_FRAMES_PER_SECOND)
           {
            Update_frames();
            animation_update_timer.start();
           }
        Flip_Buffers(_screen);
        if(fps_timer.get_ticks()<1000/FRAMES_PER_SECOND)
           SDL_Delay((1000/FRAMES_PER_SECOND)-fps_timer.get_ticks());
       }
 Clear_level_images();
 Clear();
}

void Level::Print(Texture *_screen)
{
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 attacker.Print_info(attacker.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_SIZE,0,_screen);
 defender.Print_info(defender.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_SIZE,0,_screen);
 arena.Print(_screen,MENU_OPTION_BACKGROUND->w,0);
}

void Level::Handle_Events()
{
 attacker.Handle_Events();
 defender.Handle_Events();
}

void Level::Clear()
{
 arena.Clear();
 attacker.Clear();
 defender.Clear();
}
