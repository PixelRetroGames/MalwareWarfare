#include "level.h"
#include <typeinfo>

const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

void Level::Load(char *filename)
{
 arena.Load(filename);
 arena_size=arena.Get_size();
 unit_is_placed=new int*[arena_size];
 for(int i=0;i<arena_size;i++)
     unit_is_placed[i]=new int[arena_size];
 attacker=new Attacker;
 attacker->Load(1);
 attacker->Set_available_cursor_positions(arena.Get_open_ports());
 defender=new Defender(arena_size);
 defender->Load(2);
 cpu.Load();
 cpu.Set_health(CPU_HEALTH);
 cpu.Set_screen_pos(CPU_POSITION.x,CPU_POSITION.y);
 cpu.Set_map_pos(FLOW_START_POS.x,FLOW_START_POS.y);
 for(int i=0;i<ARENA_SIZE;i++)
     for(int j=0;j<ARENA_SIZE;j++)
         {
          unit_is_placed[i][j]=-1;
          if(!arena.Is_obstacle(i,j) && !cpu.Is_in_range(i,j) && i!=0 && i!=ARENA_SIZE-1 && j!=0 && j!=ARENA_SIZE-1)
             {
              defender->Set_available_cursor_position(0,{i,j},false);
              defender->Set_available_cursor_position(1,{i,j},true);
              defender->Set_available_cursor_position(2,{i,j},false);
              for(int d=0;d<4;d++)
                  {
                   int x=i+dirx[d];
                   int y=j+diry[d];
                   if(arena.Is_obstacle(x,y) && !cpu.Is_in_range(x,y) && x>=0 && x<ARENA_SIZE && y>=0 && y<ARENA_SIZE)
                      {
                       bool corner=true,one_connection=false;
                       for(int q=0;q<4 && corner;q++)
                           {
                            int x1=x+dirx[q];
                            int y1=y+diry[q];
                            if(!arena.Is_obstacle(x1,y1))
                               {
                                if(one_connection)
                                   corner=false;
                                one_connection=true;
                                bool vertical=!(q%2);
                                if(!arena.Is_obstacle(x1+vertical,y1+!vertical) && !arena.Is_obstacle(x1-vertical,y1-!vertical))
                                   corner=false;
                               }
                           }
                       if(corner)
                          defender->Set_available_cursor_position(2,{x,y},true);
                       defender->Set_available_cursor_position(0,{x,y},true);
                      }
                   else
                      defender->Set_available_cursor_position(1,{x,y},true);
                  }
             }
         }
 //defender->Print_available_pos();
}

void Level::Update_frames()
{
 attacker->Update_units_frames();
 defender->Update_units_frames();
 for(int i=0;i<units_ids.size();i++)
     {
      units[units_ids[i]].Update_frame();
     }
 arena.Update_frames();
}

const int FRAMES_PER_SECOND=60,ANIMATION_FRAMES_PER_SECOND=8;
//const int MOVEMENT_PER_SECOND=2;

void Level::Start(Texture *_screen,char *filename)
{
 music=Mix_LoadMUS("res/music/game.mp3");
 Mix_PlayMusic(music,1);
 Load_level_images();
 Load(filename);
 #define DEBUG
 #ifndef DEBUG
 for(int i=0;i<4;i++)
     {
      attacker->Get_virus(i)->Set_first_cooldown(FIRST_COOLDOWN);
     }
 #endif // DEBUG
 bool quit=false;
 Timer fps_timer;
 Timer animation_update_timer;
 animation_update_timer.start();
 game_timer.start();
 SDL_Event event;
 bool attacker_won=false,defender_won=false;
 while(!quit && !attacker_won && !defender_won)
       {
        fps_timer.start();
        //SDL_PumpEvents();
        while(SDL_PollEvent(&event))
              {
               Update_Controllers_Events();
               Handle_Events(&event);
              }
        attacker_won=cpu.Get_health()<=0;
        defender_won=(GAME_TIME-game_timer.get_ticks())<=0;
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        Print(_screen);
        Regen_ram(game_timer.get_ticks());
        Update_frames();
        Move_units();
        if(animation_update_timer.get_ticks()>1000/ANIMATION_FRAMES_PER_SECOND)
           {
            //Move_units();
            //Update_frames();
            animation_update_timer.start();
           }
        Flip_Buffers(_screen);
        if(fps_timer.get_ticks()<1000/FRAMES_PER_SECOND)
           SDL_Delay((1000/FRAMES_PER_SECOND)-fps_timer.get_ticks());
       }
 Finish_screen(attacker_won,_screen);
 Clear_level_images();
 Clear();
 Mix_HaltMusic();
 Mix_FreeMusic(music);
}

void Level::Print_units(int x,int y,Texture *_screen)
{
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Security_service) || typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Trap))
         units[units_ids[i]].Print(x,y,_screen);
     }
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())!=typeid(Virus_cloud) &&
         typeid(*units[units_ids[i]].Get_combat_unit())!=typeid(Security_service))
         units[units_ids[i]].Print(x,y,_screen);
     }
 for(int i=0;i<units_ids.size();i++)
     {
      if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Virus_cloud))
         units[units_ids[i]].Print(x,y,_screen);
     }
}

void Level::Print_timer(int x,int y,Texture *_screen)
{
 int t=GAME_TIME-game_timer.get_ticks();
 char aux[TEXT_LENGTH_MAX]={NULL},aux1[TEXT_LENGTH_MAX]={NULL};
 itoa(t/60000,aux);
 strcat(aux,":");
 itoa((t%60000)/1000,aux1);
 if(strlen(aux1)==1)
    strcat(aux,"0");
 strcat(aux,aux1);
 Texture *timer_image=Create_TTF_Texture(MENU_FONT_BIG,aux,GAME_TIME_COLOR);
 Apply_Texture(x,y,GAME_TIME_BACKGROUND,_screen);
 Apply_Texture(x+(GAME_TIME_BACKGROUND->w-timer_image->w)/2,y+(GAME_TIME_BACKGROUND->h-timer_image->h)/2,timer_image,_screen);
 Destroy_Texture(timer_image);
}

void Level::Print(Texture *_screen)
{
 arena_buffer=Create_Transparent_Texture(ARENA_SIZE*PIXELS_PER_INGAME_UNIT,ARENA_SIZE*PIXELS_PER_INGAME_UNIT);
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 attacker->Print_info(attacker->Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_DEFAULT_SIZE,0,_screen);
 defender->Print_info(defender->Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_DEFAULT_SIZE,0,_screen);

 arena.Print(arena_buffer,0,0);
 Apply_Texture(0+attacker->Get_cursor_position().second*PIXELS_PER_INGAME_UNIT,0+attacker->Get_cursor_position().first*PIXELS_PER_INGAME_UNIT,ATTACKER_CURSOR,arena_buffer);
 if(defender->Get_cursor_position().first!=-1)
    Apply_Texture(0+defender->Get_cursor_position().second*PIXELS_PER_INGAME_UNIT,0+defender->Get_cursor_position().first*PIXELS_PER_INGAME_UNIT,DEFENDER_CURSOR,arena_buffer);
 Print_units(0,0,arena_buffer);
 effect_manager.Print(arena_buffer);
 effect_manager.Update();
 Apply_Texture({0,0,arena_buffer->w,arena_buffer->h},arena_buffer,
               {MENU_OPTION_BACKGROUND->w,0,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT,ARENA_DEFAULT_SIZE*PIXELS_PER_INGAME_UNIT},_screen);

 cpu.Print(MENU_OPTION_BACKGROUND->w,0,_screen);
 Print_timer((_screen->w-GAME_TIME_BACKGROUND->w)/2,0,_screen);
 Destroy_Texture(arena_buffer);
}

void Level::Remove_unit(int pos)
{
 std::pair<int,int> _pos=units[units_ids[pos]].Get_map_pos();
 if(typeid(*units[units_ids[pos]].Get_combat_unit())==typeid(Glitch))
    glitch_id.erase(_pos);
 else
    unit_is_placed[_pos.first][_pos.second]=-1;
 attacker->Unlock_cursor_pos(_pos);
 if(_pos.first!=0 && _pos.first!=ARENA_SIZE-1 &&
    _pos.second!=0 && _pos.second!=ARENA_SIZE-1 &&
    !cpu.Is_in_range(_pos.first,_pos.second) &&
    units[units_ids[pos]].Is_firewall())
    defender->Set_available_cursor_position(Get_firewall_type(units[units_ids[pos]].Get_combat_unit()),{_pos.first,_pos.second},true);
 int id=units_ids[pos];
 if(units[units_ids[pos]].Is_firewall())
    {
     if(typeid(*units[units_ids[pos]].Get_combat_unit())==typeid(Trap))
        defense_units_on_lane.erase(_pos);
     else
        unit_is_placed[_pos.first][_pos.second]=-1;
    }
 units[units_ids[pos]].Clear();
 units.erase(units_ids[pos]);
 units_ids.erase(units_ids.begin()+pos);
}

void Level::Move_unit(int i,int x,int y)
{
 std::pair<int,int> pos=units[units_ids[i]].Get_map_pos();
 if(typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Glitch))
    {
     glitch_id.erase(pos);
     glitch_id[{x,y}]=units_ids[i];
    }
 else
    {
     unit_is_placed[pos.first][pos.second]=-1;
     unit_is_placed[x][y]=units_ids[i];
    }
 units[units_ids[i]].Set_map_pos(x,y);
 units[units_ids[i]].Set_state(STATE_WALKING);
}

void Level::Move_units()
{
 for(int i=0;i<units_ids.size();i++)
     {
      if(units[units_ids[i]].Is_dead())
         {
          bool md=false;
          if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
             md=true;
          Unit_trigger_death_effect(i);
          if(md)
             i--;
          continue;
         }
      Unit_trigger_special_effect(i);
      std::pair<int,int> pos=units[units_ids[i]].Get_map_pos();
      if(units[units_ids[i]].Is_firewall())
         {
          /*bool attacking=false;
          for(int d=0;d<4;d++)
              {
               if(pos.first+dirx[d]>=0 && pos.first+dirx[d]<ARENA_SIZE && pos.second+diry[d]>=0 && pos.second+diry[d]<ARENA_SIZE &&
                  unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]!=-1 &&
                  units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]].Is_virus())
                  attacking=true;
              }*/
          if(units[units_ids[i]].Get_state()==STATE_ATTACKING)
             if(units[units_ids[i]].Phase_finished())
                units[units_ids[i]].Set_state(STATE_IDLE);
          if(units[units_ids[i]].Phase_finished() && units[units_ids[i]].Get_state()!=STATE_ATTACKING && units[units_ids[i]].Get_state()!=STATE_DYING)
             Check_unit_fight(i);
         }
      if(units[units_ids[i]].Is_firewall() || typeid(*units[units_ids[i]].Get_combat_unit())==typeid(Virus_cloud))
         continue;
      int d=arena.Get_flow_direction(pos.first,pos.second);
      //units[units_ids[i]].Set_angle(d);
      bool phase_finished=units[units_ids[i]].Phase_finished();
      if(phase_finished && units[units_ids[i]].Get_state()!=STATE_ATTACKING && units[units_ids[i]].Get_state()!=STATE_DYING && Check_unit_fight(i))
         {
          units[units_ids[i]].Set_angle(d);
          //Units_fight(units_ids[i],unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]);
          /*if(units[units_ids[i]].Is_dead())
             {
              bool md=false;
              if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
                 md=true;
              Unit_trigger_death_effect(i);
              if(md)
                 i--;
              //Remove_unit(i);
             }*/
         }
      else
         {
          //bool sq=units[units_ids[i]].Phase_finished();
          if(d!=-1 && (unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]==-1 || typeid(*units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]].Get_combat_unit())==typeid(Trap) ||
                       true) &&
             phase_finished)
             {
              if(pos.first==0 || pos.second==0 || pos.first==ARENA_SIZE-1 || pos.second==ARENA_SIZE-1)
                 attacker->Unlock_cursor_pos(pos);
              units[units_ids[i]].Set_angle(d);
              Move_unit(i,pos.first+dirx[d],pos.second+diry[d]);
              if(cpu.Is_in_range(pos.first+dirx[d],pos.second+diry[d]))
                 {
                  cpu.Set_health(cpu.Get_health()-1);
                  bool md=false;
                  if(typeid(units[units_ids[i]].Get_combat_unit())==typeid(Malware_defender))
                     md=true;
                  Unit_trigger_death_effect(i);
                  Remove_unit(i);
                  if(md)
                     Remove_unit(i);
                 }
             }
          /*else
             if(units[units_ids[i]].Phase_finished())
                units[units_ids[i]].Set_state(STATE_IDLE);*/
         }
     }
}

bool Level::Check_unit_fight(int id)
{
 std::pair<int,int> pos=units[units_ids[id]].Get_map_pos();
 int d=arena.Get_flow_direction(pos.first,pos.second);
 bool ret=false;
 if(units[units_ids[id]].Is_virus())
    {
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Glitch))
        return false;
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Malware) || typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trojan))
        {
         pos.first+=dirx[d];
         pos.second+=diry[d];
         d=arena.Get_flow_direction(pos.first,pos.second);
        }

    if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Malware))
       {
        for(int r=0;r<units[units_ids[id]].Get_combat_unit()->Get_radius();r++)
            {
             for(int dir=0;dir<4;dir++)
                 {
                  if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                     unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]!=-1 && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Is_firewall())
                     {
                      Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]],true);
                      ret=ret ||  (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Get_combat_unit())!=typeid(Security_service));
                     }
                 }
             pos.first+=dirx[d];
             pos.second+=diry[d];
             d=arena.Get_flow_direction(pos.first,pos.second);
            }
       }
     else
        {
         for(int dir=0;dir<4;dir++)
             {
              if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                 unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]!=-1 && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Is_firewall())
                 {
                  Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]],true);
                  ret=ret ||  (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Get_combat_unit())!=typeid(Security_service));
                 }
             }
        }
     if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trojan))
        {
         for(int dir=0;dir<4;dir++)
             {
              if(arena.Check_if_valid_pos(pos.first+dirx[dir],pos.second+diry[dir]) &&
                 unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]!=-1 && units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Is_firewall())
                 {
                  Units_fight(units_ids[id],unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]],true);
                  ret=ret ||  (typeid(*units[unit_is_placed[pos.first+dirx[dir]][pos.second+diry[dir]]].Get_combat_unit())!=typeid(Security_service));
                 }
             }
        }
    }
 else
    {
     if(!units[units_ids[id]].Is_stunned())
        {
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Firewall_plus))
            {
             int r=units[units_ids[id]].Get_combat_unit()->Get_range();
             int _x=-1,_y=-1,dist=ARENA_SIZE*ARENA_SIZE;
             for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r+1);i++)
                 {
                  for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r+1);j++)
                      {
                       if((unit_is_placed[i][j]!=-1 && units[unit_is_placed[i][j]].Is_virus()) || glitch_id.count({i,j})!=0)
                          {
                           if(arena.Get_distance_to_CPU(i,j)<dist)
                              {
                               dist=arena.Get_distance_to_CPU(i,j);
                               _x=i;
                               _y=j;
                              }
                          }
                      }
                 }
             if(_x!=-1 && _y!=-1)
                {
                 if(unit_is_placed[_x][_y]!=-1 && units[unit_is_placed[_x][_y]].Is_virus())
                    Units_fight(unit_is_placed[_x][_y],units_ids[id],false);
                 if(glitch_id.count({_x,_y})!=0)
                    Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                 ret=true;
                }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Slow_Tower))
            {
             int r=units[units_ids[id]].Get_combat_unit()->Get_range();
             for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r+1);i++)
                 {
                  for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r+1);j++)
                      {
                       if((arena.Check_if_valid_pos(i,j) && unit_is_placed[i][j]!=-1 && units[unit_is_placed[i][j]].Is_virus()) || glitch_id.count({i,j})!=0)
                          {
                           if(unit_is_placed[i][j]!=-1 && units[unit_is_placed[i][j]].Is_virus())
                              Units_fight(unit_is_placed[i][j],units_ids[id],false);
                           if(glitch_id.count({i,j})!=0)
                              Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                           ret=true;
                          }
                      }
                 }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Firewall))
            {
             for(d=0;d<4 && !ret;d++)
                 {
                  if((unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]!=-1 &&
                     units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]].Is_virus()) || glitch_id.count({pos.first+dirx[d],pos.second+diry[d]})!=0)
                     {
                      if(unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]!=-1 && units[unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]]].Is_virus())
                         Units_fight(unit_is_placed[pos.first+dirx[d]][pos.second+diry[d]],units_ids[id],false);
                      if(glitch_id.count({pos.first+dirx[d],pos.second+diry[d]})!=0)
                         Units_fight(glitch_id[{pos.first+dirx[d],pos.second+diry[d]}],units_ids[id],false);
                      ret=true;
                     }
                 }
            }
         if(typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Trap) || typeid(*units[units_ids[id]].Get_combat_unit())==typeid(Security_service))
            {
             if(unit_is_placed[pos.first][pos.second]!=-1 || glitch_id.count(pos)!=0)
                {
                 if(unit_is_placed[pos.first][pos.second]!=-1)
                    Units_fight(unit_is_placed[pos.first][pos.second],units_ids[id],false);
                 if(glitch_id.count({pos})!=0)
                    Units_fight(glitch_id[pos],units_ids[id],false);
                }
            }
        }
    }
 return ret;
}

void Level::Units_fight(int virus_id,int firewall_id,bool virus_attacked)
{
 Field_unit *virus=&units[virus_id],*firewall=&units[firewall_id];
 if(!virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Antivirus_scanner))
    {
     firewall->Set_state(STATE_ATTACKING);
     virus->Take_damage(firewall->Get_combat_unit()->Get_damage());
     if(typeid(*firewall->Get_combat_unit())==typeid(Firewall_plus))
        units[firewall_id].Set_state(STATE_ATTACKING);
    }
 if(virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     firewall->Take_damage(virus->Get_combat_unit()->Get_damage());
     effect_manager.Add_effect(0,firewall->Get_map_pos().second*PIXELS_PER_INGAME_UNIT,
                               firewall->Get_map_pos().first*PIXELS_PER_INGAME_UNIT,LEVEL_DAMAGE);
    }
 if(!virus_attacked && (typeid(*firewall->Get_combat_unit())==typeid(Security_service) || typeid(*firewall->Get_combat_unit())==typeid(Trap)))
    firewall->Take_damage(1);
 if(!virus_attacked && typeid(*firewall->Get_combat_unit())==typeid(Security_service) /*&& transformed_virus.count(firewall->Get_map_pos())==0*/)
    {
     //units[virus_id].Set_map_pos(firewall->Get_map_pos());
     int x=(rand()%4)%(std::max(1,virus->Get_combat_unit()->Get_id()==4?0:virus->Get_combat_unit()->Get_id()));
     units[virus_id].Set_unit(x==0?attacker->Get_basic_virus():attacker->Get_virus(x));
     units[virus_id].Set_damage_taken(0);
     units[virus_id].Set_state(STATE_ATTACKING);
     units[virus_id].Set_state(STATE_IDLE);
    }
 if(virus_attacked && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     units[virus_id].Set_state(STATE_ATTACKING);
    }
 if(typeid(*virus->Get_combat_unit())==typeid(Trojan) && typeid(*firewall->Get_combat_unit())!=typeid(Security_service))
    {
     firewall->Stun(virus->Get_combat_unit()->Get_stun_time());
    }
 if(typeid(*firewall->Get_combat_unit())==typeid(Slow_Tower) && !virus->Is_slowed())
    {
     virus->Slow(firewall->Get_combat_unit()->Get_slow_time());
    }
}

void Level::Unit_trigger_death_effect(int _pos)
{
 units[units_ids[_pos]].Set_state(STATE_DYING);
 if(!units[units_ids[_pos]].Phase_finished())
    return;

 /*if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Malware))
    {
     int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
     int r=units[units_ids[_pos]].Get_combat_unit()->Get_radius();
     effect_manager.Add_effect(2,(y-r+1)*PIXELS_PER_INGAME_UNIT,(x-r+1)*PIXELS_PER_INGAME_UNIT,LEVEL_EXPLOSION);
     bool damaged_cpu=false;
     for(int i=std::max(x-r,0);i<=std::min(x+r,ARENA_SIZE-1);i++)
         for(int j=std::max(y-r,0);j<=std::min(y+r,ARENA_SIZE-1);j++)
             {
              if(cpu.Is_in_range(i,j) && !damaged_cpu)
                 {
                  cpu.Set_health(cpu.Get_health()-units[units_ids[_pos]].Get_combat_unit()->Get_damage());
                  damaged_cpu=true;
                 }
              if(unit_is_placed[i][j]!=-1 && unit_is_placed[i][j]!=units_ids[_pos] && units[unit_is_placed[i][j]].Is_firewall())
                 {
                  units[unit_is_placed[i][j]].Take_damage(units[units_ids[_pos]].Get_combat_unit()->Get_damage());
                 }
             }
    }*/
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Malware_defender))
    {
     units[units_ids[_pos]].Set_unit(attacker->Get_basic_virus());
     units[units_ids[_pos]].Set_damage_taken(0);
     unit_is_placed[units[units_ids[_pos]].Get_map_pos().first][units[units_ids[_pos]].Get_map_pos().second]=units_ids[_pos];
     defender->Set_available_cursor_position(Get_firewall_type(units[units_ids[_pos]].Get_combat_unit()),units[units_ids[_pos]].Get_map_pos(),false);
     if(units[units_ids[_pos]].Get_map_pos()==attacker->Get_cursor_position())
        attacker->Lock_cursor_pos(units[units_ids[_pos]].Get_map_pos());

     return;
    }
 Remove_unit(_pos);
}

void Level::Unit_trigger_special_effect(int _pos)
{
 if(units[units_ids[_pos]].Is_stunned())
    return;
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Healer))
    {
     if(!units[units_ids[_pos]].Triggered_special_effect())
        {
         if(units[units_ids[_pos]].Special_effect_finished(2000))
            units[units_ids[_pos]].Set_state(STATE_IDLE);
         return;
        }
     units[units_ids[_pos]].Start_special_effect_timer();
     units[units_ids[_pos]].Set_state(STATE_ATTACKING);
     int r=2;
     std::pair<int,int> pos=units[units_ids[_pos]].Get_map_pos();
     for(int i=std::max(0,pos.first-r);i<std::min(ARENA_SIZE,pos.first+r);i++)
         for(int j=std::max(0,pos.second-r);j<std::min(ARENA_SIZE,pos.second+r);j++)
             {
              if(unit_is_placed[i][j]!=-1)
                 units[unit_is_placed[i][j]].Take_damage(-1);
             }
    }
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Antivirus_scanner))
    {
     bool is_triggered=false;
     //if(!units[units_ids[_pos]].Is_triggered())
        {
         int flow_dir;
         for(int i=0;i<4;i++)
             {
              int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
              if(dir_reversed[i]==arena.Get_flow_direction(x,y))
                 continue;
              int _x=x+dirx[dir_reversed[i]],_y=y+diry[dir_reversed[i]];
              if(_x>=0 && _x<ARENA_SIZE && _y>=0 && _y<ARENA_SIZE && !cpu.Is_in_range(_x,_y) && !arena.Is_obstacle(_x,_y))
                 {
                  flow_dir=i;
                  break;
                 }
             }
         flow_dir=dir_reversed[flow_dir];
         std::pair<int,int> pos;
         pos={units[units_ids[_pos]].Get_map_pos().first+dirx[flow_dir],units[units_ids[_pos]].Get_map_pos().second+diry[flow_dir]};
         while(!arena.Is_obstacle(pos.first,pos.second) && !is_triggered)
               {
                if(unit_is_placed[pos.first][pos.second]!=-1)
                   is_triggered=true;
                pos.first+=dirx[flow_dir];
                pos.second+=diry[flow_dir];
               }

         if(!is_triggered)
            return;
        }
     if(!units[units_ids[_pos]].Triggered_special_effect())
        {
         if(units[units_ids[_pos]].Special_effect_finished(ANTIVIRUS_SCANNER_SPECIAL_EFFECT_DURATION))
            units[units_ids[_pos]].Set_state(STATE_IDLE);
         return;
        }
     units[units_ids[_pos]].Start_special_effect_timer();
     units[units_ids[_pos]].Set_state(STATE_ATTACKING);
     int flow_dir;
     for(int i=0;i<4;i++)
         {
          int x=units[units_ids[_pos]].Get_map_pos().first,y=units[units_ids[_pos]].Get_map_pos().second;
          if(dir_reversed[i]==arena.Get_flow_direction(x,y))
             continue;
          int _x=x+dirx[dir_reversed[i]],_y=y+diry[dir_reversed[i]];
          if(_x>=0 && _x<ARENA_SIZE && _y>=0 && _y<ARENA_SIZE && !cpu.Is_in_range(_x,_y) && !arena.Is_obstacle(_x,_y))
             {
              flow_dir=i;
              break;
             }
         }
     flow_dir=dir_reversed[flow_dir];
     effect_manager.Add_effect(1,units[units_ids[_pos]].Get_map_pos().second*PIXELS_PER_INGAME_UNIT,
                               units[units_ids[_pos]].Get_map_pos().first*PIXELS_PER_INGAME_UNIT,ELECTROSHOCK_EFFECT[flow_dir]);
     units[units_ids[_pos]].Set_angle(flow_dir);
     std::pair<int,int> pos;
     pos={units[units_ids[_pos]].Get_map_pos().first+dirx[flow_dir],units[units_ids[_pos]].Get_map_pos().second+diry[flow_dir]};
     while(!arena.Is_obstacle(pos.first,pos.second))
           {
            if(unit_is_placed[pos.first][pos.second]!=-1 && units[unit_is_placed[pos.first][pos.second]].Is_virus() && typeid(*units[unit_is_placed[pos.first][pos.second]].Get_combat_unit())==typeid(Malware_defender))
               break;
            if(unit_is_placed[pos.first][pos.second]!=-1 && units[unit_is_placed[pos.first][pos.second]].Is_virus() && typeid(*units[unit_is_placed[pos.first][pos.second]].Get_combat_unit())!=typeid(Virus_cloud))
               {
                units[unit_is_placed[pos.first][pos.second]].Take_damage(units[units_ids[_pos]].Get_combat_unit()->Get_damage());
               }
            effect_manager.Add_effect(1,pos.second*PIXELS_PER_INGAME_UNIT,
                                      pos.first*PIXELS_PER_INGAME_UNIT,LEVEL_ELECTROSHOCK);
            pos.first+=dirx[flow_dir];
            pos.second+=diry[flow_dir];
           }
     //units[units_ids[_pos]].Take_damage(1);
    }
 if(typeid(*units[units_ids[_pos]].Get_combat_unit())==typeid(Virus_cloud))
    {
     if(!units[units_ids[_pos]].Ready_to_spawn())
        return;
     units[units_ids[_pos]].Start_spawn_timer();
     int d=arena.Get_flow_direction(units[units_ids[_pos]].Get_map_pos());
     std::pair<int,int> pos1=units[units_ids[_pos]].Get_map_pos(),pos;
     pos=pos1;
     pos.first+=dirx[d];
     pos.second+=diry[d];
     //if(unit_is_placed[pos.first][pos.second]==-1)
        {
         Add_virus(pos1,4);
         units[unit_is_placed[pos.first][pos.second]].Set_angle(arena.Get_flow_direction(pos1));
         units[units_ids[_pos]].Take_damage(1);
        }
    }
}

void Level::Add_virus(std::pair<int,int> pos,int virus_id)
{
 Field_unit aux;
 aux.Set_map_pos(pos);
 aux.Set_unit(attacker->Get_virus(virus_id));
 aux.Set_damage_taken(0);
 aux.Set_angle(arena.Get_flow_direction(aux.Get_map_pos().first,aux.Get_map_pos().second));
 int i=0;
 while(units.count(i)!=0)
       i++;

 units[i]=aux;
 units_ids.push_back(i);
 if(typeid(*aux.Get_combat_unit())==typeid(Glitch))
    glitch_id[pos]=virus_id;
 else
    unit_is_placed[aux.Get_map_pos().first][aux.Get_map_pos().second]=i;
 defender->Set_available_cursor_position(Get_firewall_type(aux.Get_combat_unit()),aux.Get_map_pos(),false);
 if(aux.Get_map_pos()==attacker->Get_cursor_position())
    attacker->Lock_cursor_pos(aux.Get_map_pos());
}

void Level::Handle_Events(SDL_Event *event)
{
 int virus_id=attacker->Handle_Events();
 if(virus_id!=-1)
    {
     attacker->Set_ram(attacker->Get_ram()-attacker->Get_virus(virus_id)->Get_ram_cost());
     Add_virus(attacker->Get_cursor_position(),virus_id);
    }
 int firewall_id=defender->Handle_Events(MENU_OPTION_BACKGROUND->w,0,event);
 if(firewall_id!=-1)
    {
     defender->Set_ram(defender->Get_ram()-defender->Get_firewall(firewall_id)->Get_ram_cost());
     Field_unit aux;
     aux.Set_map_pos(defender->Get_cursor_position());
     aux.Set_unit(defender->Get_firewall(firewall_id));
     aux.Set_damage_taken(0);
     std::pair<int,int> pos=aux.Get_map_pos();
     for(int i=0;i<4;i++)
         {
          if(arena.Get_flow_direction(pos.first,pos.second)==i)
             continue;
          int x=pos.first+dirx[i];
          int y=pos.second+diry[i];
          if(x>=0 && x<ARENA_SIZE && y>=0 && y<ARENA_SIZE && !arena.Is_obstacle(x,y))
             {
              aux.Set_angle(i);
              break;
             }
         }
     //aux.Set_angle(dir_reversed[arena.Get_flow_direction(aux.Get_map_pos().first,aux.Get_map_pos().second)]);
     int i=0;
     while(units.count(i)!=0)
           i++;
     units[i]=aux;
     units_ids.push_back(i);
     if(typeid(*units[i].Get_combat_unit())==typeid(Trap) || typeid(*units[i].Get_combat_unit())==typeid(Security_service))
        defense_units_on_lane[pos]=i;
     else
        unit_is_placed[defender->Get_cursor_position().first][defender->Get_cursor_position().second]=i;
     defender->Set_available_cursor_position(Get_firewall_type(units[i].Get_combat_unit()),defender->Get_cursor_position(),false);
     attacker->Lock_cursor_pos(defender->Get_cursor_position());
    }
}

void Level::Clear()
{
 for(int i=0;i<arena_size;i++)
     {
      delete[] unit_is_placed[i];
     }
 delete[] unit_is_placed;
 defense_units_on_lane.clear();
 std::vector<int>().swap(units_ids);
 for(std::map<int,Field_unit>::iterator i=units.begin();i!=units.end();i++)
     i->second.Clear();
 units.clear();
 effect_manager.Clear();
 cpu.Clear();
 arena.Clear();
 attacker->Clear();
 defender->Clear();
}

void Level::Regen_ram(int game_time)
{
 attacker->Regen_ram(game_time);
 defender->Regen_ram(game_time);
}

void Level::Finish_screen(bool attacker_won,Texture *_screen)
{
 Print_finish_screen(attacker_won,_screen);
 Flip_Buffers(_screen);
 bool quit=false;
 while(!quit)
       {
        SDL_PumpEvents();
        quit=keystates[SDL_SCANCODE_ESCAPE];
        Flip_Buffers(_screen);
       }
}

void Level::Print_finish_screen(bool attacker_won,Texture *_screen)
{
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 Texture *aux=Create_TTF_Texture(MENU_FONT_BIG,attacker_won?"Hacker won!":"Defender won!",{255,255,255});
 Apply_Texture((_screen->w-aux->w)/2,(_screen->h-aux->h)/2,aux,_screen);
 Destroy_Texture(aux);
 aux=Create_TTF_Texture(MENU_FONT_BIG,"Press ESCAPE to exit...",{255,255,255});
 Apply_Texture((_screen->w-aux->w)/2,_screen->h-_screen->h/4-aux->h,aux,_screen);
 Destroy_Texture(aux);
}
