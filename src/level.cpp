#include "level.h"

const SDL_Rect FLOW_START_POS={4,4,0,0};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int dir_reversed[]={2,3,0,1};

void Level::Load(char *filename)
{
 arena.Load(filename);
 attacker.Load(1);
 attacker.Set_available_cursor_positions(arena.Get_open_ports());
 defender.Load(2);
}

void Level::Update_frames()
{
 attacker.Update_units_frames();
 defender.Update_units_frames();
 arena.Update_frames();
}

const int FRAMES_PER_SECOND=60,ANIMATION_FRAMES_PER_SECOND=10;

void Level::Start(Texture *_screen,char *filename)
{
 Load_level_images();
 Load(filename);
 bool quit=false;
 Timer fps_timer;
 Timer animation_update_timer;
 animation_update_timer.start();
 while(!quit)
       {
        fps_timer.start();
        SDL_PumpEvents();
        Update_Controllers_Events();
        Handle_Events();
        quit=(controller[1].Pressed_Back_button() || controller[2].Pressed_Back_button()) || keystates[SDL_SCANCODE_ESCAPE];
        Print(_screen);
        if(animation_update_timer.get_ticks()>1000/ANIMATION_FRAMES_PER_SECOND)
           {
            Move_units();
            Update_frames();
            animation_update_timer.start();
           }
        Flip_Buffers(_screen);
        if(fps_timer.get_ticks()<1000/FRAMES_PER_SECOND)
           SDL_Delay((1000/FRAMES_PER_SECOND)-fps_timer.get_ticks());
       }
 Clear_level_images();
 Clear();
}

void Level::Print_units(int x,int y,Texture *_screen)
{
 for(int i=0;i<units.size();i++)
     {
      units[i].Print(x,y,_screen);
     }
}

void Level::Print(Texture *_screen)
{
 Apply_Texture(0,0,LEVEL_BACKGROUND,_screen);
 attacker.Print_info(attacker.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_SIZE,0,_screen);
 defender.Print_info(defender.Get_id()==1?0:MENU_OPTION_BACKGROUND->w+PIXELS_PER_INGAME_UNIT*ARENA_SIZE,0,_screen);
 arena.Print(_screen,MENU_OPTION_BACKGROUND->w,0);
 Apply_Texture(MENU_OPTION_BACKGROUND->w+attacker.Get_cursor_position().second*PIXELS_PER_INGAME_UNIT,0+attacker.Get_cursor_position().first*PIXELS_PER_INGAME_UNIT,ATTACKER_CURSOR,_screen);
 Print_units(MENU_OPTION_BACKGROUND->w,0,_screen);
}

void Level::Move_units()
{
 for(int i=0;i<units.size();i++)
     {
      std::pair<int,int> pos=units[i].Get_map_pos();
      int d=arena.Get_flow_direction(pos.first,pos.second);
      units[i].Set_map_pos(pos.first+dirx[d],pos.second+diry[d]);
     }
}

void Level::Handle_Events()
{
 int virus_id=attacker.Handle_Events();
 if(virus_id!=-1)
    {
     Field_unit aux;
     aux.Set_map_pos(attacker.Get_cursor_position());
     aux.Set_unit(attacker.Get_virus(virus_id));
     units.push_back(aux);
     attacker.Lock_cursor_pos(attacker.Get_cursor_position());
    }
 defender.Handle_Events();
}

void Level::Clear()
{
 arena.Clear();
 attacker.Clear();
 defender.Clear();
}
