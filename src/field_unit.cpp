#include "field_unit.h"
#include <typeinfo>
#include <type_traits>

const int angles[]={-90,0,90,180};
const int dirx[]={0,1,0,-1};
const int diry[]={1,0,-1,0};
const int ANIMATION_SMOOTHNESS=4,HP_HEIGHT=4;

void Field_unit::Print(int x,int y,Texture *_screen)
{
 if(map_x==0 || map_y==0 || map_x==ARENA_SIZE-1 || map_y==ARENA_SIZE-1 || Is_firewall())
    phase=ANIMATION_SMOOTHNESS;
 if(state==STATE_WALKING)
    {
     unit->Print(animation.Get_current_frame(),
                 x+(map_y-diry[angle])*PIXELS_PER_INGAME_UNIT+diry[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase),
                 y+(map_x-dirx[angle])*PIXELS_PER_INGAME_UNIT+dirx[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase),
                 angles[angle],state,_screen);
     Apply_Stretched_Texture(x+(map_y-diry[angle])*PIXELS_PER_INGAME_UNIT+diry[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase),
                             y+(map_x-dirx[angle])*PIXELS_PER_INGAME_UNIT+dirx[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase),
                             PIXELS_PER_INGAME_UNIT*(unit->Get_health()-damage_taken)/unit->Get_health(),HP_HEIGHT,PLAYER_HP_IMAGE,_screen);
     Apply_Texture(x+(map_y-diry[angle])*PIXELS_PER_INGAME_UNIT+diry[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase)+(PIXELS_PER_INGAME_UNIT-hp_image->w)/2,
                  y+(map_x-dirx[angle])*PIXELS_PER_INGAME_UNIT+dirx[angle]*(PIXELS_PER_INGAME_UNIT/ANIMATION_SMOOTHNESS*phase),
                  hp_image,_screen);
    }
 else
    {
     unit->Print(animation.Get_current_frame(),
                 x+map_y*PIXELS_PER_INGAME_UNIT,
                 y+map_x*PIXELS_PER_INGAME_UNIT,
                 angles[angle],state,_screen);
     Apply_Stretched_Texture(x+map_y*PIXELS_PER_INGAME_UNIT,
                             y+map_x*PIXELS_PER_INGAME_UNIT,
                             PIXELS_PER_INGAME_UNIT*(unit->Get_health()-damage_taken)/unit->Get_health(),HP_HEIGHT,PLAYER_HP_IMAGE,_screen);
     Apply_Texture(x+map_y*PIXELS_PER_INGAME_UNIT+(PIXELS_PER_INGAME_UNIT-hp_image->w)/2,
                   y+map_x*PIXELS_PER_INGAME_UNIT,
                   hp_image,_screen);
    }
 Update_phase();
}

const int PHASE_CHANGE_DELAY=40;

void Field_unit::Update_phase()
{
 if(phase_timer.get_ticks()>PHASE_CHANGE_DELAY)
    {
     phase++;
     if(phase>ANIMATION_SMOOTHNESS)
        phase=ANIMATION_SMOOTHNESS;
     phase_timer.start();
    }
}

void Field_unit::Clear()
{
 //animation.Clear();
 Destroy_Texture(hp_image);
}

Field_unit::Field_unit()
{
 angle=0;
 phase=0;
 state=STATE_IDLE;
 map_x=map_y=0;
 special_effect_timer.start();
}

void Field_unit::Set_map_pos(int x,int y)
{
 map_x=x;
 map_y=y;
 phase=0;
 phase_timer.start();
}

void Field_unit::Set_map_pos(std::pair<int,int> pos)
{
 Set_map_pos(pos.first,pos.second);
}

void Field_unit::Set_damage_taken(int _damage_taken)
{
 damage_taken=std::min(_damage_taken,unit->Get_health());
 char aux[TEXT_LENGTH_MAX]={NULL},aux1[TEXT_LENGTH_MAX]={NULL};
 itoa(unit->Get_health()-damage_taken,aux1);
 strcat(aux,aux1);
 strcat(aux," / ");
 itoa(unit->Get_health(),aux1);
 strcat(aux,aux1);
 Destroy_Texture(hp_image);
 hp_image=Create_TTF_Texture(MENU_FONT_SMALL,aux,PLAYER_HP_COLOR);
}

void Field_unit::Take_damage(int _damage)
{
 Set_damage_taken(damage_taken+_damage);
}

void Field_unit::Set_unit(Combat_unit *_unit)
{
 unit=_unit;
 animation=unit->Get_animation(state);
}

void Field_unit::Set_angle(int _angle)
{
 angle=_angle;
}

void Field_unit::Set_state(int _state)
{
 if(state!=_state)
    {
     phase=0;
     animation=unit->Get_animation(_state);
    }
 state=_state;
}

std::pair<int,int> Field_unit::Get_map_pos()
{
 return std::make_pair(map_x,map_y);
}

Combat_unit *Field_unit::Get_combat_unit()
{
 return unit;
}

int Field_unit::Get_phase()
{
 return phase;
}

int Field_unit::Get_state()
{
 return state;
}

bool Field_unit::Is_dead()
{
 return damage_taken>=unit->Get_health();
}

bool Field_unit::Phase_finished()
{
 return phase==ANIMATION_SMOOTHNESS;
}

bool Field_unit::Is_firewall()
{
 return (typeid(*unit)==typeid(Firewall) || typeid(*unit)==typeid(Firewall_plus) || typeid(*unit)==typeid(Antivirus_scanner) || typeid(*unit)==typeid(Security_service));
}

bool Field_unit::Is_virus()
{
 return !Is_firewall();
}

bool Field_unit::Triggered_special_effect()
{
 if(special_effect_timer.get_ticks()>unit->Get_attack_delay())
    {
     special_effect_timer.start();
     return true;
    }
 return false;
}

void Field_unit::Update_frame()
{
 animation.Update_frame();
}
