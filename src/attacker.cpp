#include "attacker.h"

const int NUMBER_OF_VIRUS_TYPES=5;
const char *VIRUS_TYPES[]={"virus_cloud","malware","malware_defender","trojan","basic_virus","glitch","twins"};

int Attacker::Get_type(char *type)
{
 for(int i=0;i<NUMBER_OF_VIRUS_TYPES;i++)
     if(strcmp(type,VIRUS_TYPES[i])==0)
        return i;
 SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR,"Invalid virus type",type,NULL);
 exit(-1);
}

char PATH_TO_ALL_VIRUSES[]={"res/virus/all.mwav"};

void Attacker::Load(int _id)
{
 Set_id(_id);
 FILE *in=fopen(PATH_TO_ALL_VIRUSES,"r");
 for(int i=0;i<NUMBER_OF_VIRUS_TYPES;i++)
     {
      char path[TEXT_LENGTH_MAX];
      fgets(path,sizeof path,in);
      int sq=strlen(path);
      if(path[sq-1]=='\n')
         path[sq-1]=NULL;
      char type[TEXT_LENGTH_MAX];
      fgets(type,sizeof type,in);
      sq=strlen(type);
      if(type[sq-1]=='\n')
         type[sq-1]=NULL;
      Virus *aux;
      switch(Get_type(type))
             {
              case 0: aux=new Virus_cloud;
                      break;
              case 1: aux=new Malware;
                      break;
              case 2: aux=new Malware_defender;
                      break;
              case 3: aux=new Trojan;
                      break;
              case 4: aux=new Virus;
                      break;
              case 5: aux=new Glitch;
                      break;
              case 6: aux=new Glitch;
             }
      aux->Load(path,i);
      if(Get_type(type)==4 && i!=0)
         basic_virus=aux;
      else
         unit.push_back(aux);
     }
 fclose(in);
 char aux[TEXT_LENGTH_MAX];
 strcpy(aux,"P");
 strcat(aux,_id==1?"1":"2");
 strcat(aux," - hacker");
 player_image=Create_TTF_Texture(MENU_FONT_BIG,aux,ATTACKER_ID_COLOR);
 event_timer.start();
 memset(blocked,0,100);
 Set_ram(INITIAL_RAM_ATTACKER);
}

void Attacker::Clear()
{
 Player::Clear();
 cursor_pos=0;
 std::vector<std::pair<int,int> >().swap(available_cursor_positions);
}

void Attacker::Reset()
{
 Set_ram(0);
 for(int i=0;i<4;i++)
     unit[i]->Reset();
 event_timer.start();
 cursor_pos=0;
 std::vector<std::pair<int,int> >().swap(available_cursor_positions);
}

Virus *Attacker::Get_virus(int _id)
{
 if(_id==4)
    return basic_virus;
 return Get_unit(_id);
}

Virus *Attacker::Get_basic_virus()
{
 return basic_virus;
}

std::pair<int,int> Attacker::Get_cursor_position()
{
 return available_cursor_positions[cursor_pos];
}

void Attacker::Set_available_cursor_positions(std::vector<std::pair<int,int>> _av_curs)
{
 available_cursor_positions=_av_curs;
 //blocked.reserve(_av_curs.size());
}

void Attacker::Lock_cursor_pos(std::pair<int,int> _pos)
{
 for(int i=0;i<available_cursor_positions.size();i++)
     if(available_cursor_positions[i]==_pos)
        {
         blocked[i]=true;
         return;
         if(i==cursor_pos)
            {
             int dist=0,dist2=0;
             while(blocked[cursor_pos] && cursor_pos<available_cursor_positions.size()-1)
                   cursor_pos++,dist++;
             if(blocked[cursor_pos])
                {
                 dist++;
                 cursor_pos=0;
                 while(blocked[cursor_pos] && cursor_pos<i)
                       cursor_pos++,dist++;
                }
             int c=i;
             while(blocked[c] && c>1)
                   c--,dist2++;
             if(!blocked[c])
                {
                 if(dist2<dist)
                    cursor_pos=c;
                 return;
                }
             dist2++;
             c=available_cursor_positions.size()-1;
             while(blocked[c] && c>i+1)
                   c--,dist2++;
             if(dist2<dist)
                cursor_pos=c;
            }
         return;
        }
}

void Attacker::Unlock_cursor_pos(std::pair<int,int> _pos)
{
 for(int i=0;i<available_cursor_positions.size();i++)
     if(available_cursor_positions[i]==_pos)
        {
         blocked[i]=false;
         return;
        }
}

bool Attacker::Can_cast(int _id)
{
 return (unit[_id]->Is_cool() && unit[_id]->Is_enough_ram(ram));
}

//const int EVENT_DELAY=100;
const SDL_Scancode keys[2]={SDL_SCANCODE_UP,SDL_SCANCODE_DOWN};

int Attacker::Handle_Events()
{
 int ret=-1;
 if(!blocked[cursor_pos])
    {
     ret=Player::Handle_Events();
     if(ret!=-1)
        unit[ret]->Start_cooldown();
    }
 if(Player::event_timer.get_ticks()>EVENT_DELAY)
    {
     if(keystates[keys[0]] || (CONTROLLER_SCHEME==CONTROLLER_SCHEME_CONTROLLERS && (controller[id].Pressed_Up() || controller[id].Get_StickY()<-AXIS_DEAD_ZONE)))
        {
         Player::event_timer.start();
         int init=cursor_pos;
         do
            {
             cursor_pos--;
             if(cursor_pos<0)
                cursor_pos=available_cursor_positions.size()-1;
            }
         while(blocked[cursor_pos] && cursor_pos!=init);
        }
     if(keystates[keys[1]] || (CONTROLLER_SCHEME==CONTROLLER_SCHEME_CONTROLLERS && (controller[id].Pressed_Down() || controller[id].Get_StickY()>AXIS_DEAD_ZONE)))
        {
         Player::event_timer.start();
         int init=cursor_pos;
         do
            {
             cursor_pos++;
             cursor_pos%=available_cursor_positions.size();
            }
         while(blocked[cursor_pos] && cursor_pos!=init);
        }
    }
 return ret;
}

void Attacker::Print_info(int x,int y,Texture *_screen)
{
 Apply_Texture(x,y,MENU_BACKGROUND_ATTACKER,_screen);
 Player::Print_info(x,y,_screen);
 Apply_Texture(x+(MENU_OPTION_BACKGROUND->w-player_image->w)/2,y+(_screen->h-NUMBER_OF_UNITS_ON_PAGE*MENU_OPTION_BACKGROUND->h-player_image->h-ram_image->h)/2,player_image,_screen);
 Print_ram(x+(MENU_OPTION_BACKGROUND->w-ram_image->w)/2,y+(_screen->h-NUMBER_OF_UNITS_ON_PAGE*MENU_OPTION_BACKGROUND->h-player_image->h-ram_image->h)/2+player_image->h,_screen);
}

void Attacker::Update_units_frames()
{
 Player::Update_units_frames();
}

void Attacker::Regen_ram(int game_time)
{
 if(ram_regen_timer.get_ticks()>RAM_REGEN_DELAY_ATTACK/(game_time>GAME_TIME/2?2:1) && ram+1<=RAM_LIMIT)
    {
     Set_ram(ram+1);
    }
}
